# RUNSCRIPT[¶](#RUNSCRIPT)

## НАЗВАНИЕ[¶](#НАЗВАНИЕ)

**runscript** - интерпретатор сценариев оболочки для служб

## СИНТАКСИС[¶](#СИНТАКСИС)

**runscript** \[**-D , -nodeps** \] \[**-d , -debug** \] \[**-s , -ifstarted** \] \[**-Z , -dry-run** \] \[_команда_ ... \]

## ОПИСАНИЕ[¶](#ОПИСАНИЕ)

**runscript** фактически представляет собой интерпретатор shell-сценариев, предоставляющий простой интерфейс для зачастую сложных системных команд и демонов. Когда какая-либо служба вызывает команду, она сначала загружает множественный конфигурационный файл, затем управляющий им конфигурационный файл, далее /etc/rc.conf и, наконец, сам сценарий. Здесь **runscript** запускает заданную команду.

Команды определяются в сценарии как функции оболочки. Ниже приведен перечень функций, по умолчанию доступных для всех сценариев запуска:

_describe_

Описывает поведение службы и каждую команду, определяемую ей.

_start_

Прежде всего необходимо убедиться, что все службы, от которых зависит нормальная работа, запущены. Если какие-либо необходимые службы выдают ошибку при запуске, будет выполнен выход и выведено соответствующее сообщение; если же всё благополучно, вызывается функция запуска, если она существует.

_stop_

Прежде всего необходимо убедиться, что все службы, которые зависят от текущих операций, остановлены. Если какие-либо из этих служб выдают ошибку при остановке, будет выполнен выход и выведено соответствующее сообщение; если же всё благополучно, вызывается функция остановки, если она существует.

_restart_

Останавливает, а затем вновь запускает службу, вместе с зависимыми от нее.

_status_

Отображает текущее состояние службы. Будет возвращен соответствующий ему код, за исключением состояния "запущено" (started), при котором возвращается 0, для соответствия стандартному поведению команд.

_zap_

Устанавливает состояние службы "остановлено" (stopped) и удаляет все сохраненные данные о ней.

Следующие опции определяют параметры запуска службы:

**-d , -debug**

Включить xtrace в оболочке для отладки.

**-D , -nodeps**

Полностью игнорировать информацию о зависимостях, предоставляемую службой.

**-s , -ifstarted**

Выполнить команду, только если служба была запущена.

**-q , -quiet**

Отключить весь информационный вывод, генерируемый службой. Это не влияет на вывод любых других команд, не связанных с OpenRC.

**-v , -verbose**

Показывать дополнительный информационный вывод, генерируемый службой.

**-Z , -dry-run**

Показать, какие службы будут остановлены и/или запущены, но не останавливать / не запускать их.

Следующие переменные определяют сценарий службы:

_extra\_commands_

Перечень дополнительных команд, определяемых службой, через пробел.

_extra\_started\_commands_

Перечень дополнительных команд, определяемых службой, через пробел. Работает только в том случае, если служба уже запущена.

_extra\_stopped\_commands_

Перечень дополнительных команд, определяемых службой, через пробел. Работает только в том случае, если служба уже остановлена.

_description_

Строка описания службы.

_description\_$command_

Строка, описывающая дополнительную команду.

_start\_stop\_daemon\_args_

Список аргументов, передаваемых start-stop-daemon'у при запуске службы.

_command_

Демон, обеспечивающий запуск и остановку посредством start-stop-daemon, если функция запуска-остановки не определена службой.

_command\_args_

Список аргументов, передаваемых демону при запуске.

_pidfile_

Файл идентификатора процесса, используемый предыдущей командой.

_name_

Имя, используемое предыдущей командой.

_retry_

Количество попыток, которые будут предприняты при остановке службы. Это может быть как ожидание в секундах, так и многократные пары сигнал/ожидание (аналогично SIGTERM/5).

## ЗАВИСИМОСТИ[¶](#ЗАВИСИМОСТИ)

Чтобы **runscript** запускался и останавливался в нужный момент по отношению к другим службам, вы должны определить **функцию зависимости**. Поскольку это функция, **depend** допускает самую тонкую настройку (см. пример ниже). Перечислим здесь функции, которые могут выступать в качестве **функции зависимости**. Вы просто передаете им имена служб, которые следует добавить к данному типу зависимости, а для удаления какой-либо службы сопровождаете ее префиксом !.

_need_

Служба не будет запускаться до запуска необходимых служб и не прекратит работу, пока службы, которым она необходима, не будут остановлены.

_use_

Служба попытается запустить другие используемые службы, добавленные на уровень запуска.

_after_

Служба будет запущена после данных служб и остановлена перед их остановкой.

_before_

Служба будет запущена перед запуском данных служб и остановлена после их остановки.

_provide_

Обеспечить данную виртуальную службу. Например, named обеспечивает dns.

_config_

Необходимо заново вычислить зависимости, поскольку файлы изменились.

_keyword_

Пометить службу ключевым словом. На данный момент поддерживаются следующие ключевые слова:

**-shutdown**

Не останавливать службу при выходе из системы. Как правило, оставшиеся демоны могут получать сигнал SIGTERM непосредственно перед конечным закрытием. Это ключевое слово обычно имеют службы, обеспечивающие работу в сети, такие как сценарии запуска network и dhcpcd.

**-stop**

Не останавливать службу при переходе на следующий уровень запуска, даже если его нет. Для выхода из системы.

**-timeout**

Другие службы должны ожидать вплоть до запуска службы. Используйте данное ключевое слово, если запуск службы может занять более минуты.

**-jail**

При виртуализации полностью исключать службу из зависимостей. Ее можно будет запустить, вызвав напрямую. Настройка через переменную **rc\_sys** в файле /etc/rc.conf

**-lxc**

Аналогично -jail, но для виртуализации на уровне операционной системы (LXC, Linux Resource Containers).

**-openvz**

Аналогично -jail, но для систем OpenVZ.

**-prefix**

Аналогично -jail, но для систем Prefix.

**-uml**

Аналогично -jail, но для систем UML.

**-vserver**

Аналогично -jail, но для систем VServer.

**-xen0**

Аналогично -jail, но для систем Xen DOM0\.

**-xenu**

Аналогично -jail, но для систем Xen DOMU.

О том, как переопределять зависимости с помощью конфигурационных файлов, см. раздел **ФАЙЛЫ**.

## ВСТРОЕННЫЕ ФУНКЦИИ[¶](#ВСТРОЕННЫЕ-ФУНКЦИИ)

**runscript** определяет некоторые встроенные функции, к которым вы можете обращаться из ваших служебных сценариев:

**einfo** \[_строка_ \]

Выводит зеленый астериск перед строкой.

**ewarn** \[_строка_ \]

Выводит желтый астериск перед строкой.

**eerror** \[_строка_ \]

Выводит красный астериск перед строкой.

**ebegin** \[_строка_ \]

Аналогично einfo, но с многоточием в конце.

**eend** _возвращаемая\_величина_ \[_строка_ \]

Если _возвращаемая\_величина_ не равна 0, выводит строку с **eerror** и **!!** в квадратных скобках в конце. Иначе выводить ok в квадратных скобках в конце строки. Возвращается значение _возвращаемой\_величины_.

**ewend** _возвращаемая\_величина_ \[_строка_ \]

Аналогично **eend**, но вместо **eerror** использовать **ewarn**.

Перечисленные команды могут иметь префикс **v**: в этом случае они будут действовать, только если переменная окружения _EINFO\_VERBOSE_ имеет значение true.

**ewaitfile** _время файл1 файл2_ ...

Ожидать время в секундах, пока не будут перебраны все файлы. Если все файлы существуют, возвращает 0, иначе значение, отличное от единицы. Если значение времени меньше 1, ожидание будет бесконечным.

**is\_newer\_than** _файл1 файл2_ ...

Если файл1 новее файла2, возвращает 0, иначе 1\. Если файл2 - каталог, проверяет также его содержимое.

**is\_older\_than** _файл1 файл2_ ...

Если файл1 новее файла2, возвращает 0, иначе 1\. Если файл2 - каталог, проверяет также его содержимое.

**service\_set\_value** _значение\_имени_

Сохраняет _значение\_имени_ для дальнейшего восстановления. Когда служба прекратит свою работу, сохраненные значения будут утрачены.

**service\_get\_value** _имя_

Возвращает сохраненное значение под _именем_.

**service\_started** \[_служба_ \]

Если служба запущена, возвращает 0, иначе 1\.

**service\_starting** \[_служба_ \]

Если служба запускается, возвращает 0, иначе 1\.

**service\_inactive** \[_служба_ \]

Если служба неактивна, возвращает 0, иначе 1\.

**service\_stopping** \[_служба_ \]

Если служба прекращает свою работу, возвращает 0, иначе 1\.

**service\_stopped** \[_служба_ \]

Если служба остановлена, возвращает 0, иначе 1\.

**service\_coldplugged** \[_служба_ \]

При холодном запуске службы возвращает 0, иначе 1\.

**service\_wasinactive** \[_служба_ \]

Если служба была неактивна, возвращает 0, иначе 1\.

**service\_started\_daemon** \[_служба_ \] _демон_ \[_индекс_ \]

Если служба запустила демон через **start-stop-daemon**, возвращает 0, иначе 1\. Если был указан индекс, это должен быть pid демона, запущенного службой.

**mark\_service\_started** \[_служба_ \]

Пометить службу как запущенную.

**mark\_service\_starting** \[_служба_ \]

Пометить службу как начинающую работу.

**mark\_service\_inactive** \[_служба_ \]

Пометить службу как неактивную.

**mark\_service\_stopping** \[_служба_ \]

Пометить службу как завершающую работу.

**mark\_service\_stopped** \[_служба_ \]

Пометить службу как остановленную.

**mark\_service\_coldplugged** \[_служба_ \]

Пометить службу как службу с холодной загрузкой.

**mark\_service\_wasinactive** \[_служба_ \]

Пометить службу как неактивную.

**checkpath**

\[**-d , -directory** \] \[**-f , -file** \] \[**-m , -mode** _режим_ \] \[**-o , owner** _владелец_ \] _путь_ ...

Проверяет существование _пути_, его типа, его _владельца_, _режимы_ доступа. Если при проверке обнаруживается ошибка, путь будет исправлен.

**yesno** _значение_

Если значение соответствует YES, TRUE, ON или 1, возвращает 0 независимо от регистра, иначе возвращает 1\.

## ОКРУЖЕНИЕ[¶](#ОКРУЖЕНИЕ)

**runscript** присваивает значения следующим переменным окружения, которые можно использовать в сценариях служб:

_RC\_SVCNAME_

Имя службы.

_RC\_RUNLEVEL_

Текущий уровень запуска, на котором находится rc.

_RC\_BOOTLEVEL_

Выбран загрузочный уровень запуска. По умолчанию - boot.

_RC\_DEFAULTLEVEL_

Выбран основной уровень запуска. По умолчанию - default.

_RC\_SYS_

Специальная переменная для дополнительного описания системы. Может принимать значения OPENVZ, XENU, XEN0, UML и VSERVER.

_RC\_UNAME_

Результат выполнения команды \`uname -s\`.

## ФАЙЛЫ[¶](#ФАЙЛЫ)

Файлы конфигурации, связанные с расположением службы. Если уже существует файл, оканчивающийся на .${RC\_RUNLEVEL}, будет использован он.

**../conf.d/${RC\_SVCNAME%%.\*}**

Множественный конфигурационный файл. Например: если ${RC\_SVCNAME} - net.eth1, обращаться к ../conf.d/net.

**../conf.d/${RC\_SVCNAME}**

Конфигурационный файл службы.

**/etc/rc.conf**

Конфигурационный файл хоста.

За исключением /etc/rc.conf, конфигурационные файлы могут также переопределять зависимости служб с помощью переменных. Просто добавьте к зависимости префикс rc\_. Примеры:  

    # В то время как большинство служб не требуют определенного интерфейса, наша
    # конфигурация openvpn в таковом нуждается, а именно в bge0.
    rc_need="net.bge0" 
    # В файле /etc/rc.conf пропишем
    rc_openvpn_need="net.bge0" 
    
    # Службы не должны зависеть от интерфейса tap1 для сетевой работы,
    # но нам необходимо добавить net.tap1 к уровню запуска default.
    rc_provide="!net" 
    # В файле /etc/conf.d/net пропишем
    rc_provide_tap1="!net" 
    # В файле /etc/rc.conf пропишем
    rc_net_tap1_provide="!net" 
    
    # Ключевые слова можно использовать с отрицанием. Это особенно удобно для пользователей prefix,
    # тестирующих OpenRC.
    rc_keyword="!noprefix"

## ПРИМЕРЫ[¶](#ПРИМЕРЫ)

Ниже приводится пример сценария службы для foo.

    #!/sbin/runscript
    command=/usr/bin/foo
    command_args="${foo_args} --bar" 
    pidfile=/var/run/foo.pid
    name="FooBar Daemon" 
    
    description="FooBar is a daemon that eats and drinks" 
    extra_commands="show" 
    extra_started_commands="drink eat" 
    description_drink="Opens mouth and reflexively swallows" 
    description_eat="Chews food in mouth" 
    description_show="Shows what's in the tummy" 
    
    _need_dbus()
    {
        grep -q dbus /etc/foo/plugins
    }
    
    depend()
    {
        # Мы сохраняем файл идентификатора процесса и пишем в каталог /var/cache, поэтому нам потребуется localmount:
        need localmount
        # Мы можем использовать сеть, но это не обязательно:
        use net
        # Служба должна следовать за bootmisc, чтобы каталог /var/run инициализировался до того,
        # как мы поместим туда файл идентификатора процесса:
        after bootmisc
    
        # Foo может использовать демон dbus.
        # Но если бы добавим dbus, пока foo работает,
        # и потом остановим dbus, нам не нужно останавливать foo, поскольку foo не использовала dbus:
        config /etc/foo/plugins
        local _need=
        if service_started; then
            _need=`service_get_value need`
        else
            if _need_dbus; then
               _need="${_need} dbus" 
            fi
        fi
        need ${_need}
    }
    
    start_pre()
    {
        # Убедимся, что наши каталоги не содержат ошибок:
        checkpath --dir --owner foo:foo --mode 0664 \
            /var/run/foo /var/cache/foo
    }
    
    start_post()
    {
        # Сохраним необходимую службу:
        if _need_dbus; then
            service_set_value need dbus
        fi
    }
    
    stop_post() {
        # Удалим мусор:
        rm -rf /var/cache/foo/*
    }
    
    drink()
    {
        ebegin "Starting to drink" 
        ${command} --drink beer
        eend $? "Failed to drink any beer :(" 
    }
    
    eat()
    {
        local result=0 retval= ate= food=
        ebegin "Starting to eat" 
    
        if yesno "${foo_diet}"; then
            eend 1 "We are on a diet!" 
            return 1
        fi
    
        for food in /usr/share/food/*; do
            veinfo "Eating `basename ${food}`" 
            ${command} --eat ${food}
            retval=$?
            : $((${result} += ${retval}))
            [ ${retval} = 0 ] && ate="${ate} `basename ${food}`" 
        done
    
        if eend ${result} "Failed to eat all the food"; then
            service_set_value ate "${ate}" 
        fi
    }
    
    show()
    {
        einfo "Foo has eaten: `service_get_value ate`" 
    }

## ОШИБКИ[¶](#ОШИБКИ)

По причинам, связанным со способом загрузки конфигурационных файлов и необходимостью обрабатывать несколько служебных каталогов, вы можете использовать в каталогах служб только символические ссылки на другие службы из того же каталога. Вы не можете создавать символическую ссылку, указывающую на службу из другого каталога, даже если другой служебный каталог.

is\_older\_than должна бы возвращать 0 при успешной отработке, однако в этом случае она возвращает 1, для совместимости с базовым набором (baselayout) Gentoo. Мы рекомендуем пользователям использовать функцию is\_newer\_, которая работает привычным образом.

## СМ. ТАКЖЕ[¶](#СМ-ТАКЖЕ)

**einfo**(3), **[rc](.html)**(8), **[rc-status](.html)**(8), **[rc-update](.html)**(8), **rc\_plugin\_hook**(3), **sh**(1p), **[start-stop-daemon](.html)**(8), **uname**(1)

## АВТОРЫ[¶](#АВТОРЫ)

* Roy Marples <[roy@marples.name](mailto:roy@marples.name)\>

## ПЕРЕВОД[¶](#ПЕРЕВОД)

* Елена Гаврилова <[e.vl.gavrilova@yandex.ru](mailto:e.vl.gavrilova@yandex.ru)\>