# eix[¶](#eix)

## НАЗВАНИЕ[¶](#НАЗВАНИЕ)

**eix** - набор утилит для поиска, определения различий и обновления бинарного кэша из вашего локального дерева

## СИНТАКСИС[¶](#СИНТАКСИС)

**eix** \[_общие опции_\] \[_ОПЦИИ_\] _ВЫРАЖЕНИЕ_

**eix-update** \[_общие опции_\] \[_опции eix-update_\]

**eix-diff** \[_общие опции_\] _СТАРЫЙ КЭШ_ \[_НОВЫЙ КЭШ_\]

**eix-sync**

**eix-test-obsolete**

**eix-remote**

**eix-layman**

**eix-installed-after**

**eix-installed**

**eix-functions.sh**

**versionsort**

## ОПИСАНИЕ[¶](#ОПИСАНИЕ)

**eix-update** генерирует бинарный кэш локального дерева портежей и оверлеев. **eix** позволяет осуществлять в этом кэше поиск, ограничивая его условиями, указанными в _ВЫРАЖЕНИи_. Соответственно, если вы не указываете таких условий, будут выведены все пакеты. **eix-diff** сравнивает два бинарных кэша на предмет обнаружения пакетов, которые были добавлены, удалены или пакеты с новыми стабильными версиями.

Все перечисленные программы и сценарии обращаются к конфигурационным файлам, которые будут описаны ниже. **eix-sync** дополнительно имеет собственный конфигурационный файл.

**eix-sync** умеет синхронизировать дерево портежей/оверлеев и сравнивать новые данные со старым кэшем с помощью **eix-diff**. Для получения подробной справки по **eix-sync** выполните **eix-sync -h**. Вам также следует обратиться к документации по файлу _/etc/eix-sync.conf_ (см. ниже); заметьте, что его содержимое может также сохраняться в переменной **EIX\_SYNC\_CONF**.

**eix-test-obsolete** - сценарий, несколько раз вызывающий **eix** для структурированного вывода **eix -tTc**.

**eix-remote** позволяет синхронизировать текущую базу eix с внешним сервером, добавляя/удаляя из неё данные. Заметьте, что при следующем вызове eix-update данные, полученные с сервера, обнулятся; чтобы обойти это поведение, следует включить **KEEP\_VIRTUALS=true** в /etc/eixrc. Для получения подробной справки по **eix-remote** выполните **eix-remote -h**, а также обратитесь к документации по файлу _/etc/eix-remote.conf_ (см. ниже).

**eix-layman** умеет добавлять локальные оверлеи layman к текущей базе данных и удалять их из нее. Этот сценарий полезен в том случае, если вы не указываете источник данных для layman в локальном _/etc/make.conf_. Для получения подробной справки по **eix-layman** выполните **eix-layman -h**. **eix-layman** также является примером использования **eix-functions.sh**.

**eix-installed-after** - простой и хорошо откомментированный сценарий, демонстрирующий некоторые возможности кастомизации формата вывода eix. Он выводит перечень пакетов, установленных до (или после) последней (или первой) установки определённого пакета/версии. Для получения подробной справки выполните **eix-installed-after -h**.

**eix-functions.sh** предоставляет вспомогательные функции, вызываемые **eix-sync**, **eix-remote** и **eix-layman**. Их можно использовать и при написании собственных подобных сценариев. Заметьте, что сразу после назначения источников данных для **eix-functions.sh**, вероятно, потребуется вызвать **read\_functions** \[_АРГУМЕНТЫ_\] для передачи соответствующих _АРГУМЕНТов_ functions.sh программе baselayout .

**eix-installed** представляет собой простой сценарий, который выводит все установленные пакеты (с их точными версиями), а также может осуществлять поиск пакетов, установленных как с информацией о репозитарии или данными времени сборки, так и без таковой (ср. описание переменных **CHECK\_INSTALLED\_OVERLAYS** и **USE\_BUILD\_TIME**). Для получения подробной справки по **eix-installed** выполните **eix-installed -h**.

**versionsort** - вспомогательная утилита для сценариев, которая убирает номера версий из аргументов и выводит их, отсортировав согласно правилам сортировки версий portage. Подробнее см. в конце этой man-страницы.

## ПРИМЕРЫ[¶](#ПРИМЕРЫ)

Нижеследующие примеры демонстрируют некоторые полезные, но не вполне привычные случаи использования eix. Мы приводим их, чтобы показать широту возможностей утилиты. Поскольку предполагается, что примеры могут копироваться непосредственно со справочной страницы, мы приводим их здесь с минимальным описанием. Для понимания принципа их работы следует, разумеется, полностью ознакомиться с руководством. Дополнительные примеры можно посмотреть, например, в сценарии **eix-installed-after** - он снабжен пространными комментариями.

_команда_**| eix '-|\*' --format '<markedversions:NAMESLOT\>'**  
p((((. Подразумевая, что _команда_ создает список в формате **категория/пакет-версия** или **=категория/пакет-версия**, будет вывыведен соответствующий список в виде **категория/пакет** или **категория/пакет:СЛОТ** (в зависимости от того, релевантно ли значение **СЛОТа**).

_команда_**| eix '-|\*' --format '<markedversions:NAMEASLOT\>'**

Аналогично предыдущей команде, но вывод всегда будет в виде **категория/пакет:СЛОТ**, даже если значение **СЛОТа** излишне. (Легко запомнить: **A**lways ("всегда")).

**eix '-I\*' --format '<installedversions:NAMEVERSION\>'**

Будут отображены установленные пакеты в виде **категория/пакет-версия**. Очевидно, что формат вывода можно изменить, вместо **NAMEVERSION** используя **NAMESLOT** или **NAMEASLOT**. В таком окружении единственное предназначение опции **-I** заключается в некотором ускорении вывода.

**eix '-I\*' --format '<installedversions:EQNAMEVERSION\>'**

Аналогично предыдущей команде, но вывод будет произведен в виде **=категория/пакет-имя**, обеспечивая тем самым прямую передачу данных portage.

**eix '-I\*' --format '<installedversions:DATESORT\>' | sort -n | cut -f2-3**

Будут выведены установленные пакеты (если слоты имеют значение, то со слотами), в порядке, соответствующем дате установки. Е сли вам желателен вывод в ином формате, следует заменить **DATESORT** подходящей переменной (исходное определение вывода вы можете видеть, выполнив **eix --dump**).

Вот как определяется порядок вывода запрошенных пакетов: переменная **DATESORT** формирует первый столбец, отображая в нем прошедшее время в секундах (если выполнить команду **eix --print DATESORT**, вы увидите, что за это отвечает переменная **DATESORT\_DATE**, первая запись в которой - **%s**). Затем программа **sort** перестраивает список пакетов в алфавитном порядке. В последнюю очередь вызывается программа **cut**, которая отсекает первый столбец, который был нужен только для сортировки.

В приведенных выше примерах **NAMEVERSION** и **DATESORT** - имена переменных, предопределенных в eix (чтобы их увидеть, выполните **eix --dump**). Но ничто не мешает вам также определить и использовать собственные переменные. Работа с ними описана в man-руководстве; обратите особое внимание на описание строки **FORMAT**. }}}

## ОПЦИИ[¶](#ОПЦИИ)

### Общие опции[¶](#-Общие-опции)

Здесь перечисляются опции, общие для **eix**, **eix-diff** и **eix-update**.

**-h**, **--help**

Вывести справку и выйти.

**-Q**, **--quick** (переключатель) (не используется с **eix-update**)

(Не) считывать слоты установленных версий, которые невозможно предположить (например, установленные версии пакетов с как минимум двумя различными слотами, для которых в базе данных уже нет установленной версии). Учтите, что при использовании этой опции eix и eix-diff могут выдавать ложноположительные результаты при рекомендациях по обновлению/откату таких пакетов.

**--care** (не используется с **eix-update**)

Отключить опцию --quick; кроме того, слоты установленной версии всегда будут считываться, а не определяться предположительно. В частности, при изменении имени слота установленной версии система проверит наличие рекомендации по обновлению/откату. Учтите, что при этом значительно замедлится скорость первого вызова. (Если ваша файловая система использует кэш разумной величины, только первого - последующие вызовы должны выполняться почти с такой же скоростью, как если бы эта опция не использовалась.)

**-q**, **--quiet** (переключатель)

Отключить стандартный вывод утилиты в консоль. Вы можете уменьшить время выполнения eix, используя эту опцию в связке либо с **--brief**, либо с **--brief2** (в зависимости от того, что вам нужно) и установив значение переменной **COUNT\_ONLY\_PRINTED=false**. См. также переменные **NOFOUND\_STATUS** и **MOREFOUND\_STATUS**

**--dump**

Показать действующие значения переменных eixrc, а значения по умолчанию будут отображены как комментарии; затем выйти.

**--dump-defaults**

Показать значения по умолчанию переменных eixrc, а действующие значения будут отображены как комментарии; затем выйти.

**--print **_ПЕРЕМЕННАЯ_

Вывести значение указанной аргументом _ПЕРЕМЕННОЙ_ eixrc или portage, в расширенном виде, предназначенном для внутреннего использования eix; затем выйти. Прежде всего это полезно в сценариях или для отладки. Если вы используете данную опцию в сценариях, вам может потребоваться указать также значение **PRINT\_APPEND** для поддержки закрывающих пробелов (см. описание **PRINT\_APPEND**).

**-V**, **--version**

Вывести номер версии и выйти.

**-n**, **--nocolor**

Отключить использование цветового кода ANSI. Это имеет смысл для терминалов, не поддерживающих ANSI. (Данная опция автоматически включается, если стандартный вывод - не терминал, но может быть переопределена использованием опции --force-color)

**-F**, **--force-color**

Поведение, обратное --nocolor.

### Особые опции информирования[¶](#-Особые-опции-информирования)

Следующие особые опции информирования работают только с бинарным кэшем **eix**. Это одноразовые исключающие опции - иными словами, при их использовании eix выведет только требуемые данные и завершит работу.

**--print-overlay-path **_оверлей_\_

Вывести путь к первому оверлею, соответствущему запрошенному _ОВЕРЛЕю_. В качестве _ОВЕРЛЕя_ можно указывать метку оверлея, путь (маску) или число.

**--print-overlay-label **_оверлей_

Вывести метку оверлея, соответствущую запрошенному _ОВЕРЛЕю_. В качестве _ОВЕРЛЕя_ можно указывать метку оверлея, путь (маску) или число.

**--print-all-useflags**

Вывести все IUSE words, используемые в определенном пакете.

**--print-all-keywords**

Вывести все ключевые слова, используемые в определенном пакете.

**--print-all-slots**

Вывести все строки слотов, используемые в определенном пакете.

**--print-all-provides**

Вывести все строки PROVIDE, используемые в определенном пакете.

**--print-all-licenses**

Вывести все строки LICENSE, используемые в определенном пакете.

**--print-world-sets**

Вывести сеты world.

**--is-current**

Проверить только, доступен и корректен ли **/var/cache/eix** (в версии, поддерживаемой бинарным **eix**). Если да, то eix успешно завершает работу, не выводя никаких сведений.

### Опции вывода[¶](#-Опции-вывода)

**-x**, **--versionsort** (переключатель)

Вывести доступные версии, отсортировав их по слотам/версиям. Если сортировка производится по слотам, на каждой строке должен располагаться только один слот.

**-l**, **--versionlines** (переключатель)

Вывести доступные версии (вертикальным списком). Кроме того, данные о IUSE будут отображаться отдельно для каждой версии (а не для всего пакета).

**-c**, **--compact** (переключатель)

Использовать компактный формат вывода результатов поиска eix. Это удобно, если выводится длинный перечень; кроме того, тем самым ускоряется поиск на медленных соединениях, например, при использовании серийной консоли.

**-v**, **--verbose** (переключатель)

Использовать подробный вывод с дополнительной информацией о результатах поиска - например, сообщать о лицензии, под которой распространяется пакет.

**--xml** (переключатель)

Использовать вывод в формате XML. Если вы хотите передать эту опцию внешней программе, возможно, потребуется использовать ее в связке с **--care** и экспортировать некоторые переменные, такие как **LOCAL\_PORTAGE\_CONFIG**, чтобы убедиться, что пользовательские настройки вывода не влияли на ваш вывод. Когда опция включена, автоматически включаются также **OVERLAYS\_LIST=none** и **--pure-packages**. Формат вывода можно незначительно модифицировать с помощью переменных **XML\_\***. Используемый XML-формат документирован и хранится в удобочитаемом виде в файле eix-xml.html или eix-xml.txt, а в менее удобном для восприятия виде (как xml-схема) - в файле eix-xml.xsd.

**-\***, **--pure-packages** (переключатель)

(Не забывайте ставить кавычки, если используете краткую форму в оболочке.) Исключить вывод в конце дополнительной информации (имен оверлеев, количество найденных пакетов). Это может пригодиться при использовании сценариев интерпретатора с парсингом вывода.

**--only-names** (переключатель)

Как "-\*", но дополнительно выводить только категории и имена запрошенных пакетов.

**-0**, **--brief** (переключатель)

Вывести максимум один пакет и остановиться. Как правило, выполнение этой опции можно ускорить, назначив **COUNT\_ONLY\_PRINTED=false**. В этом последнем случае при поиске по приблизительному соответствию могут быть выведены не самые последние доступные для установки версии.

**--brief2** (переключатель)

Как **--brief**, но вывод будет ограничен двумя пакетами.

### Особые опции **eix**[¶](#-Особые-опции-eix)

**-t**, **--test-non-matching**

Перед очередным выводом отображать записи в /etc/portage/package.\*, которые не соответствуют ни одной существующей версии в базе данных пакетов или пусты и не имеют смысла (см. **TEST\_FOR\_EMPTY**).

Эта опция выводит также все установленные, но не фигурирующие в базе данных пакеты.

Заметьте, что она действует совершенно иначе, нежели **-T** (см. ниже), которая только проверяет пакеты **в базе данных** на предмет наличия в /etc/portage/package.\* дублированных записей или, соответственно, доступности установленных версий.

Эту опцию предпочтительнее использовать в связке с **-T**, для очистки /etc/portage/package.\*

Можно совмещать ее и с опцией **-e**, чтобы избежать дополнительного вывода.

Если по какой-либо причине вы хотите исключить отдельные записи/пакеты из числа проверяемых, вам следует поместь соответствующие записи в файл /etc/portage/package.\*.nonexistent, где \*=keywords,mask,unmask,use,env,cflags,installed. Эти файлы и порядок их переименования будут описаны ниже.

**--cache-file **_ФАЙЛ_

Использовать _ФАЙЛ_ вместо **/var/cache/eix**.

### Опции ВЫРАЖЕНИЯ[¶](#-Опции-ВЫРАЖЕНИЯ)

ВЫРАЖЕНИЕ используется для ограничения вывода пакетов при вызове eix.

ВЫРАЖЕНИЕ может содержать булевы операторы и условия, согласно следующему синтаксису:

ВЫРАЖЕНИЕ ::= \[ **--not** | **-!** \] ФИГУРНАЯ\_СКОБКА\_ИЛИ\_ПРОВЕРКА |

ВЫРАЖЕНИЕ \[ **--and**| **-a** \] ВЫРАЖЕНИЕ |

ВЫРАЖЕНИЕ \[ **--or** | **-o** \] ВЫРАЖЕНИЕ |

ФИГУРНАЯ\_СКОБКА\_ИЛИ\_ПРОВЕРКА ::= **--open**|**-(** ВЫРАЖЕНИЕ **--close**|**-)** |

ПРОВЕРКА\_ПО\_КРИТЕРИЯМ

ПРОВЕРКА\_ПО\_КРИТЕРИЯМ ::= \[КРИТЕРИИ\_ПРОВЕРКИ\] \[ШАБЛОН\]

Не забывайте, что в интерпретаторе символы **!**, **(**, **)** необходимо заключать в кавычки, чтобы eix распознал их как часть аргумента!

Если вам необходимо, чтобы ВЫРАЖЕНИЕ начиналось с **-**, поставьте впереди два дефиса подряд: **--**. Тогда ВЫРАЖЕНИЕ не будет воспринято как опция, а добавочные символы **--** будут проигнорированы. Например, команда **eix ---tool --or ---util** выведет пакеты, содержащие **-tool** или **-util**.

Думается, значение логических операторов очевидно - за исключением, может быть, следующих особенностей:

1\. Если между двумя ВЫРАЖЕНИями не стоит ни **--and**|**-a**, ни **--or**|**-o**, молчаливо принимается один из операторов. Какой из них - **-a** или **-o** - зависит от значения переменной конфигурации **DEFAULT\_IS\_OR**.

2\. Операторы **-a** и **-o** имеют одинаковый приоритет, а содержащая их строка имеет левую ассоциативность. Иными словами, **X -o Y -a Z** не будет выполнено, если не выполнено **Z**.

3\. **--not**|**-!** отрицает только результат следующего элемента ФИГУРНАЯ\_СКОБКА\_ИЛИ\_ПРОВЕРКА.

4\. Если ШАБЛОН опущен, по умолчанию используется пустой ШАБЛОН. Например, при стандартных настройках **eix**, будучи вызван без аргументов, выведет все пакеты, поскольку каждое имя содержит пустую строку. С другой стороны, **eix -e**, как правило, не должен выводить ничего, ведь не существует пакета с именем, _в точности_ совпадающим с пустой строкой.

5\. Заметьте, синтаксис подразумевает, что ШАБЛОН всегда завершает выражение. КРИТЕРИИ\_ПРОВЕРКИ после ШАБЛОНа всегда начинают новое выражение (т.е. неявно подставляется **--and** или **--or**, в зависимости от значения переменной **DEFAULT\_IS\_OR**). Так, команда **eix -e foo** не эквивалентна **eix foo -e**. Вторая запись означает то же, что и **eix foo --and -e** или **eix foo --or -e**, в зависимости от значения **DEFAULT\_IS\_OR**.

6\. Имейте в виду, что КРИТЕРИИ\_ПРОВЕРКИ могут включать несколько опций. Все они применяются одновременно, в том смысле, что они соединены логическим **и** (каково бы ни было значение переменной **DEFAULT\_IS\_OR**). Здесь присутствует некоторая двусмысленность, поскольку ШАБЛОН можно опустить. Во избежание этой двусмысленности последовательные КРИТЕРИИ\_ПРОВЕРКИ всегда рассматриваются как часть одной ПРОВЕРКИ\_ПО\_КРИТЕРИЯМ. Например, в команде **eix -I -O -e foo** все опции рассматриваются как часть одного _ВЫРАЖЕНИЯ_ (а не четырех, как это было бы в случае записи **eix -I '' -O '' -e '' foo**). С другой стороны, в команде **eix -I --not -e** оператор **--not** заставит следующий КРИТЕРИЙ\_ПРОВЕРКИ **-e** воспринимать как относящийся к новому _ВЫРАЖЕНИю_. Опции, отличные от КРИТЕРИЕВ\_ПРОВЕРКИ и логических операторов (таких как **-!**, **-(**, **-)**, **-a**, **-o**), здесь игнорируются. Например, **eix -I -c -e** генерирует только одно _ВЫРАЖЕНИЕ_, поскольку **-c** не является ни КРИТЕРИЕМ\_ПРОВЕРКИ, ни логическим оператором, а следовательно, не влияет на интерпретацию _ВЫРАЖЕНИя_.

7\. КРИТЕРИИ\_ПРОВЕРКИ могут определять **алгоритм соответствия** и **выбор операции**. Они относятся **только** к текущей ПРОВЕРКЕ\_ПО\_КРИТЕРИЯМ - в частности, они включены только для следующего **ШАБЛОНА**.

Знайте, что выражения можно использовать как в описанном синтаксисе, так и для неявного отбора пакетов по другим критериям, пусть это и займет дополнительное время. Для этого следует определить **FORMATSTRING** (см. ниже) с использованием условных выражений так, чтобы eix для нежелательных пакетов выводила пустую строку.

Вот допустимые КРИТЕРИИ\_ПРОВЕРКИ:

**-I**, **--installed**

Искать только среди установленных пакетов. Не используйте эту опцию вместо **eix-installed -a**, **qlist -ICv** или **equery** - они дают разные результаты. В данном случае в выводе не окажется пакетов, которые установлены, но были исключены из дерева портежей или оверлеев; впрочем, их лучше вовсе не иметь в системе (разумно будет помещать их в оверлеи на случай, если вдруг потребуется переустановка). Для обнаружения таких пакетов вы можете использовать команду **eix -te** (или **eix -tI** для включения в вывод и установленных пакетов из портежей), но имейте в виду, что обычные правила **FORMAT** не распространяются на eix -t. Таким образом, не следует включать эту опцию в сценариях, если вы не вполне уверены в своих действиях.

Если вы все же решите использовать ее в сценарии вместо equery, есть смысл делать это вместе с одной из следующих опций:

**--format --only-names**

**--format '<installedversions:NAMEVERSION\>' --pure-packages**

**--format '<installedversions:EQNAMEVERSION\>' --pure-packages**

**--format '<installedversions:NAMESLOT\>' --pure-packages**

**--format '<installedversions:NAMEASLOT\>' --pure-packages**

**--format '<installedversions:DATESORT\>' --pure-packages**

**-i**, **--multi-installed**

Искать только среди пакетов, имеющих как минимум две разных установленных версии. Как правило, это означает, что версии были помещены в разные слоты (во время установки).

**-d**, **--dup-packages**

Искать только среди дублирующих друг друга пакетов: например, sys-foo/bar может быть доступен как в официальном дереве портежей, так и в локальном оверлее. Если включена переменная **DUP\_PACKAGES\_ONLY\_OVERLAYS** (см. ниже), искомые пакеты должны находится в двух разных оверлеях.

**-D**, **--dup-versions**

Искать только среди пакетов с дублирующими друг друга версиями: например, sys-foo/bar-0.2.1 может быть доступен как в официальном дереве портежей, так и в локальном оверлее. Если включена переменная **DUP\_VERSIONS\_ONLY\_OVERLAYS** (см. ниже), искомые пакеты должны оба находится в оверлеях.

**-1**, **--slotted**

Искать только среди пакетов с непустым слотом, т.е. с непустым и отличным от "0" значением SLOT.

**-2**, **--slots**

Искать только среди пакетов с по крайней мере двумя различными слотами. В отличие от опции -1, здесь, если доступен только один слот, например, "4.3", пакет не будет отображен.

**-u**, **--upgrade**, **--upgrade+**, **--upgrade-**

Искать только среди пакетов, имеющих как минимум одну установленную версию пакета в слоте, которая не является лучшей версией в этом слоте. Как правило, это означает, что вам следует либо обновить пакет, либо откатиться до более ранней версии.

Впрочем, проверка будет произведена с учетом значения переменной **UPGRADE\_TO\_HIGHEST\_SLOT** (см. ниже).

Если вы использовали опции **--upgrade+** или **--upgrade-**, операция осуществляется так, как если бы **LOCAL\_PORTAGE\_CONFIG** имела значение **true** или **false**. Иначе утилита будет исходить из значения переменной **UPGRADE\_LOCAL\_MODE**.

Если вы хотите, чтобы отображались только пакеты, рекомендуемые для отката, вам следует обратиться к функциям **FORMATSTRING** (описание см. ниже).

**--stable**, **--testing**, **--non-masked**, **--system**, **--system-plain+**

Искать только среди пакетов, хотя бы одна версия которых, соответственно, является стабильной (и не замаскированной), тестируемой или стабильной (и не замаскированной), не замаскированной, системной или виртуальным пакетом, только системной. Если в одном запросе вы совмещаете несколько опций из этого ряда, будет отображена только та версия, которая удовлетворяет им всем.

**--stable+**, **--testing+**, **--non-masked+**, **--system+**, **--system-plain+**

Аналогично описанному выше, но временно принимается значение переменной **LOCAL\_PORTAGE\_CONFIG=true**.

**--stable-**, **--testing-**, **--non-masked-**, **--system-**, **--system-plain-**

Аналогично описанному выше, но временно принимается значение переменной **LOCAL\_PORTAGE\_CONFIG=false**.

**--installed-unstable**, **--installed-testing**, **--installed-masked**

Искать только среди пакетов, у которых установлена хотя бы одна версия, соответственно, нестабильная, тестируемая или замаскированная (временно принимается значение переменной **LOCAL\_PORTAGE\_CONFIG=false**). Если в одном запросе вы совмещаете несколько опций из этого ряда, будет выведена только та версия, которая удовлетворяет им всем.

**--world**, **--world-plain**

Искать только среди пакетов сета @world (а при **--world** - и среди пакетов-виртуалов для @world). Сопоставимо с "emerge @world", так как включает в поиск не только пакеты, перечисленные в файле world, но и пакеты из world-сетов и сета @system. Если вам это не нужно, выберите другую опцию для более узкой выборки.

**--world-file**, **--world-plain**

Искать только среди пакетов, фигурирующих в файле world или сете @system. При использовании опции **--world-file** будут отображаться и соответствующие им виртуальные пакеты.

**--world-set**, **--world-set-plain**

Искать только среди пакетов из файла world\_sets или из сета @system. При использовании опции **--world-set** будут отображаться и соответствующие им виртуальные пакеты.

**--selected**, **--selected-plain**

Искать только среди пакетов из сета @selected. Сопоставимо с "emerge @selected", так как включает в поиск не только пакеты, перечисленные в файле world, но и пакеты из world-сетов и сета @system. (Если пакеты из сета @system у вас включены в файл world\_sets, то вывод команды, разумеется, будет идентичен выводу при опции **--world**). При использовании опции **--selected** в вывод будут включены соответствующие пакеты-виртуалы. Если вам это не нужно, выберите другую опцию для более узкой выборки.

**--selected-file**, **--selected-file-plain**

Искать только среди пакетов из файла world. При использовании опции **--selected-file** в вывод будут включены также соответствующие виртуальные пакеты.

**--selected-set**, **--selected-set-plain**

Искать только среди пакетов из файла world\_set. При использовании опции **--selected-set** в вывод будут включены также соответствующие виртуальные пакеты.

**--binary**

Искать только среди пакетов с бинарным файлом (\*.tbz2-архивом) в PKGDIR. Версия бинарного файла должна совпадать с доступной либо установленной версией пакета. (Заметьте, однако, что если доступной версии нет, пакет также не будет обнаружен.) Проверяется только существование соответствующего \*.tbz2-архива. Может ли portage использовать его - это уже другой вопрос, и ответ на него зависит также от состояния метаданных в \*.tbz2 (например, от настроек USE), но eix за это не отвечает.

**-O**, **--overlay**

Искать только среди пакетов с как минимум одной версией в оверлее.

**--in-overlay **_оверлей_

Искать только среди пакетов с как минимум одной версией в оверлее, удовлетворяющем шаблону _оверлей_ в аргументе.

Допускаются множественные аргументы: повторите опцию нужное количество раз, указав таким образом все _оверлеи_, которые хотите включить в поиск.

_оверлей_ может представлять собой либо шаблон, либо число. Обратите внимание, что, используя предлагаемое по умолчанию значение переменной **OVERLAYS\_LIST=all-used-renumbered**, вы не увидите корректной нумерации оверлеев; чтобы узнать правильный номер интересующего вас оверлея, необходимо вызвать:

**OVERLAYS\_LIST=all eix --not**

...а в сценариях - лучше так:

**OVERLAYS\_LIST=all PRINT\_COUNT\_ALWAYS=never eix -!**

Специальные значения **0** и **$PORTDIR** соответствуют основному дереву портежей (оно условно принимается за нулевой оверлей).

Если аргумент _оверлей_ пуст (или опущен, если последняя опция **--in-overlay**), поиск будет произведен по всем оверлеям, кроме основного дерева портежей (т.е. **--in-overlay ''** работает идентично **-O**).

**--only-in-overlay **_оверлей_

Искать среди пакетов с версиями только в оверлее, соответствующем шаблону _оверлей_.

Допускаются множественные аргументы: повторите опцию нужное количество раз, указав таким образом все _оверлеи_, которые хотите включить в поиск.

_оверлей_ может представлять собой либо шаблон, либо число, аналогично **--in-overlay**. **--only-in-overlay ''** выведет все соответствующие аргументу пакеты не из официального дерева портежей, доступные только в оверлеях.

**-J**, **--installed-overlay**

Искать только среди пакетов, установленных из какого-либо оверлея. Чтобы обеспечить надежность результатов, укажите значением переменной **CHECK\_INSTALLED\_OVERLAYS** true (это значение не выставлено по умолчанию, потому что значительно замедляет работу утилиты). Подробнее см. в описании переменной **CHECK\_INSTALLED\_OVERLAYS**.

**--installed-from-overlay **_оверлей_

Эта опция аналогична **--in-overlay** с той разницей, что поиск будет произведен только среди пакетов, хотя бы одна версия которых установлена из _оверлея_. Например, по запросу **--installed-from-overlay 0** будут выведены только те пакеты, хотя бы одна версия которых была установлена из дерева портежей. Чтобы обеспечить надежный результат при использовании -J, выставите значением переменной **CHECK\_INSTALLED\_OVERLAYS** true.

**--installed-in-some-overlay**

Искать только среди пакетов с по крайней мере одной установленной версией, доступной также в оверлеях.

**--installed-in-overlay **_оверлей_

Опция аналогична **--in-overlay** с той разницей, что поиск ведется только среди пакетов, хотя бы одна установленная версия которых существует в _оверлее_. Так, если задать **--installed-in-overlay 0**, будут выведены только те пакеты, у которых установлена хотя бы одна версия, доступная также в основном дереве портежей.

**--restrict-fetch**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=fetch. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-mirror**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=mirror. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-primaryuri**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=primaryuri. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-binchecks**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=binchecks. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-strip**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=strip. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-test**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=test. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-userpriv**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=userpriv. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-installsources**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=installsources. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-bindist**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=bindist. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--restrict-parallel**

Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=parallel. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--properties-interactive**

Искать только среди пакетов, у которых хотя бы для одной версии PROPERTIES=interactive. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--properties-live**

Искать только среди пакетов, у которых хотя бы для одной версии PROPERTIES=live. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--properties-virtual**

Искать только среди пакетов, у которых хотя бы для одной версии PROPERTIES=virtual. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**--properties-set**

Искать только среди пакетов, у которых хотя бы для одной версии PROPERTIES=set. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем.

**-T**, **--test-obsolete**

Искать только среди устаревших пакетов.

Пакеты считаются устаревшими, если им соответствуют дублирующие друг друга записи в /etc/portage/package.\* (при условии, что переменная **TEST\_FOR\_REDUNDANCY** имеет значение true) или если не все установленные версии существуют (при условии, что переменная **TEST\_FOR\_NONEXISTENT** имеет значение true).

Определение дублирования содержится в переменных **REDUNDANT\_IF**, описанных ниже, а определение несуществования - в переменных **NONEXISTENT\_IF**. Обратите внимание, что проверка версий пакетов из устаревших оверлеев надежна только в том случае, если переменная **CHECK\_INSTALLED\_OVERLAYS** у вас имеет значение true (это не значение по умолчанию, поскольку при его использовании проверка значительно замедляется). Подробнее см. в описании переменной **CHECK\_INSTALLED\_OVERLAYS**.

Учтите, что данная опция обеспечивает проверку только тех пакетов, которых находятся в базе данных - в частности, при ее использовании вы не обнаружите в выводе записей, соответствующих переименованным или удаленным пакетам (из дерева портежей). Если вы хотите увидеть именно их, используйте **-t**.

Итак, для поиска устаревших записей другого рода целесообразно применять данную опцию в связке с -t.

Если по какой-либо причине вы хотите исключить из проверки некоторые пакеты, вы можете внести соответствующие записи в файл (или каталог) /etc/portage/package.nowarn. Он будет описан ниже; там же вы найдете информацию о том, как указывать альтернативные/дополнительные файлы).

**-|**, **--pipe**

(Помните, что интерпретатор команд не обработает символ **|** без кавычек.)

Искать только среди пакетов из стандартного ввода. Как правило, эту опцию удобно использовать в конвейере, например, перенаправляя вывод emerge -pv (аналогично genlop -p). Будут обработаны все данные, формат которых содержит следующие слова (через пробел или знак новой строки):

_категория_**/**_пакет_**-**_версия_ или

_категория_**/**_пакет_

Кроме того, все пакеты/версии, обработанные таким образом, в выводе будут маркированы. Подробнее о маркировании см. в описании строк формата **marked** и **markedversions:\***.

Даже если опция **--pipe** встречается несколько раз, стандартный ввод, разумеется, будет считан лишь единожды, но каждое вхождение опции обрабатывается отдельно (т.е. если первая --pipe выдает соответствие, то выдадут соответствие и остальные).

Если вы хотите использовать стандартный ввод только для маркирования, но не для выбора, можно использовать выражение вида

**eix something -a "-(" --pipe -o "-)"**

### Выбор поля соответствия[¶](#-Выбор-поля-соответствия)

Следующие опции определяют поля критериев, на соответствие которым будет проверяться шаблон.

Одно выражение может включать несколько полей (выражение удовлетворяет запросу, если шаблон удовлетворяет хотя бы одному из указанных полей). Если вы не укажете некоторые из приведенных опций, по умолчанию будет выбрано поле соответствия **--name**, но если у вас особый шаблон - например, вида "категория/пакет" или "@сет", вместо этого по умолчанию будет использовано поле соответствия **--category-name**, **--set**, **--description**, **--homepage**, **--virtual** или **--license**. Параметры эвристической процедуры определяются переменной конфигурации **DEFAULT\_MATCH\_FIELD** (подробнее о ней см. ниже).

**-s**, **--name**

В аргументе, например, eix.

**-S**, **--description**

В аргументе, например, Small utility for searching.

**-C**, **--category**

В аргументе, например, app-portage.

**-A**, **--category-name**

В аргументе, например, app-portage/eix.

**-H**, **--homepage**

В аргументе, например, [http://eix.berlios.de/](http://eix.berlios.de/).

**-L**, **--license**

В аргументе, например, GPL-2\.

**-P**, **--provide**

В аргументе, например, virtual/blackbox.

**--set**

В аргументе - имя локального сета пакетов версии, содержащейся в базе данных (т.е. соответствующей файлу в каталоге **/etc/portage/sets**, **/etc/portage/sets.eix**, или другом каталоге из значений переменной **EIX\_LOCAL\_SETS\_ADD**; см. комментарии к **EIX\_LOCAL\_SETS**). Сеты system и world здесь преднамеренно не учитываются; для их сканирования следует использовать опции **--system\[+-\]**, **--world**, **--world-all** и **--world-sets**.

**--slot**

В аргументе - имя слота версии в базе данных, например, kde-4\.

**--installed-slot**

В аргументе - имя слота установленной версии. Помните, что без опции **--care** (или выставленного значения переменной **CAREMODE=true**) имя слота может быть только предположено.

**-U**, **--use**

В аргументе - USE-флаг, определенный IUSE в некоторой версии некоторыми ебилдами пакета. Чаще всего эта опция используется вместе с -e.

**--installed-with-use**

В аргументе - USE-флаг, который был включен при установке пакета. Разумеется, поиск в этом случае ведется только среди установленных пакетов. Заметьте, что это относится и к опции **-I** - в обоих случаях в обработку будут включены только пакеты, в настоящий момент присутствующие в базе данных.

**--installed-without-use**

В аргументе - USE-флаг, который был отключен при установке пакета. Разумеется, поиск в этом случае ведется только среди установленных пакетов. Заметьте, что это относится и к опции **-I** - в обоих случаях в обработку будут включены только пакеты, в настоящий момент присутствующие в базе данных.

### Алгоритм соответствия[¶](#-Алгоритм-соответствия)

Нижеследующие опции определяют алгоритм, по которому поля соответствия будут соотнесены с шаблоном. Для одного соответствия можно выбрать только один алгоритм. Если вы опустите какие-либо из этих опций, значение по умолчанию будет определено эвристически, в зависимости от вида шаблона, по которому ведется поиск. В большинстве случаев по умолчанию будет использована опция **--regex**, за исключениев случаев, когда вид шаблона говорит о том, что это glob-шаблон или подстрока (тогда по умолчанию используется соответствующий алгоритм), или когда шаблон имеет особый вид, например, или _категория/пакет_ или _@сет_ - в этом случае большинство пользователей ожидают поиска по всей строке или, соответственно, по началу строки. Параметры эвристической процедуры определяются переменной конфигурации **DEFAULT\_MATCH\_ALGORITHM** (подробнее о ней см. ниже).

**-e**, **--exact**

В аргументе - точная (полная) строка шаблона. Например, команда eix -e gcc выведет только пакеты gcc.

**-b**, **--begin**

Шаблон находится в начале строки. Так, команда eix -b gcc выведет не только пакет gcc, но и, например, gcc-config.

**--end**

Шаблон находится в конце строки.

**-z**, **--substring**

Шаблон находится в пределах строки.

**-f** \[_N_\], **--fuzzy** \[_N_\]

Будет произведен приблизительный поиск с максимальным расстоянием Левенштейна _N_ (по умолчанию) для всей строки. Имейте в виду, что использование этой опции замедляет поиск.

**-p**, **--pattern**

В аргументе - подстановочный шаблон (для всей строки). Подробности см. в справке по **fnmatch**(3) и/или **glob**(7). Убедитесь, что шаблоны заключены в одинарные кавычки (чтобы оболочка не перехватывала подстановочные знаки).

**-r**, **--regex**

В аргументе - регулярное выражение. Оно ищется только как подстрока (если только не используются символы ^, $); пустой шаблон вызывает вывод всех пакетов. Более подробную информацию об этом вы найдете в man-руководстве **regex**(7). Как и в предыдущем случае, убедитесь, что шаблон заключен в одинарные кавычки.

### Определение формата вывода (см. ниже **FORMATSTRING**)[¶](#-Определение-формата-вывода-см-ниже-FORMATSTRING)

**--format** _ФОРМАТ_

Назначить _ФОРМАТ_ стандартным форматом вывода результатов поиска.

**--format-compact** _ФОРМАТ_

Назначить _ФОРМАТ_ компактным форматом вывода результатов поиска.

**--format-verbose** _FORMAT_

Назначить _ФОРМАТ_ подробным форматом вывода результатов поиска.

### Особые опции для **eix-update**[¶](#-Особые-опции-для-eix-update)

**-o** _файл\_вывода_, **--output** _файл\_вывода_

При использовании этой опции **eix-update** запишет базу данных eix не в **/var/cache/eix**, а в _файл\_вывода_, не проверяя и не меняя права доступа к этому файлу.

**-a** _оверлей_, **--add-overlay** _оверлей_

Эта опция аналогична добавлению _оверлея_ в значения переменной **PORTDIR\_OVERLAY** в файле /etc/make.conf или изменению **ADD\_OVERLAY**, но имеет то преимущество, что вам нет нужды редактировать переменные, а кроме того, вы можете использовать пробелы в аргументе. Оверлеи, добавленные с помощью данной опции, идут следом за оверлеями, добавленными через **KEEP\_VIRTUALS**. Если _оверлей_ уже фигурирует в списке оверлеев, эта опция отработает вхолостую. Опция может быть использована несколько раз, для добавления нескольких оверлеев.

**-x** _оверлей_, **--exclude-overlay** _оверлей_

Эта опция аналогична добавлению _оверлея_ в значения переменной **EXCLUDE\_OVERLAY**, но имеет то преимущество, что вам нет нужды редактировать переменную, а кроме того, вы можете использовать пробелы в аргументе. _оверлей_ здесь рассматривается как маска. Все удовлетворяющие шаблону оверлеи (даже те, которые были добавлены с помощью описанных ниже опций **--add-overlay**) исключаются из списка оверлеев. Каталог **PORTDIR** рассматривается как обычный оверлей, который также может быть исключен (в таком случае в качестве **PORTDIR** будет сохранен первый _оверлей_ из перечисленных). Опция может быть использована несколько раз, для исключения нескольких оверлеев.

**-m** _оверлей_ _метод_, **--override-method** _оверлей_ _метод_

Изменить текущий метод кэширования _оверлея_ (каталог **PORTDIR** считается допустимым _оверлеем_) на указанный аргументом _метод_. _оверлей_ рассматривается как маска, т.е. может содержать подстановочные знаки. Если _оверлей_ не сопоставлен ни одной записи в списке оверлеев, эта опция отработает вхолостую. Данная опция аналогична добавлению записи "_оверлей_ _метод_" в конец переменной **OVERRIDE\_CACHE\_METHOD**. Опция может быть использована несколько раз, для переопределения метода кэширования для нескольких оверлеев. Приоритет имеет последнее значение. В частности, значение, переопределенное с помощью данной опции, будет иметь приоритет над значением **OVERRIDE\_CACHE\_METHOD**.

**-r** _путь-к-оверлею_ _метка-оверлея_, **--repo-name** _путь-к-оверлею_ _метка-оверлея_

Оверлей, расположенный по адресу _путь-к-оверлею_, получит _метку-оверлея_, независимо от других настроек. Это поведение можно переопределить через **REPO\_NAMES**. В отличие от значения **REPO\_NAMES**, _путь-к-оверлею_ представляет собой не шаблон, а точный путь.

## ВЫВОД[¶](#ВЫВОД)

### Слоты[¶](#-Слоты)

В отличие от обычного вывода версий в emerge, **eix** может отображать также имена слотов, если они непусты и отличны от нуля. Это поведение определяется содержимым **FORMATSTRING**.

Если слоты отображаются, то имя слота либо отделяется от номера версии двоеточием, либо заключается в скобки. Вы можете выбрать предпочтительный формат разделителя, редактируя переменную **COLON\_SLOTS**.

Если переменная **PROPERTIES** или **RESTRICT** определена в ебилде, это по умолчанию показывается в строке версии; более тонкая настройка доступна путем редактирования переменных конфигурации.

Вот несколько примеров:

**4.1.1:4.1** или **4.1.1(4.1)**

Версия 4.1.1 будет установлена в слот 4.1\.

**3.14p:GNAT-3.14p** или **3.14p(GNAT-3.14p)**

Версия 3.14p будет установлена в слот GNAT-3.14p.

**2.0.0\_rc1-r6**

Версия 2.0.0\_rc1-r6, значение SLOT либо пусто, либо "0".

**1.0+i+l+v+s!f!m!p!b!s!t!u!i!d!P{tbz2}**

Версия 1.0, для которой PROPERTIES="interactive live virtual set", а также RESTRICT="fetch mirror primaryuri binchecks strip test userpriv installsources bindist parallel" Кроме того, в **PKGDIR**. существует \*.tbz2-архив (бинарный пакет) для этой версии.

**5.0-r3(5.0R3)!f**

Версия 5.0-r3 будет установлена в слот 5.0R3, с ограничением по загрузке.

### Маскировка[¶](#-Маскировка)

Достаточно поработать с gentoo неделю, чтобы легко опознавать формат маскировки в строках версий. Тем не менее мы напомним об этом на нескольких примерах. Разумеется, изложенное ниже относится только к стандартным настройкам; чтобы изменить параметры, используйте параметры конфигурации.

**\[P\]2.95.3-r8**

Если в файлах пакетов вашего профиля была обнаружена маска пакета, но данная версия не совпадает с ней, говорят, что версия "замаскирована профилем".

**\[M\]4.0.0\_alpha20050213**

Версия совпадает с маской из /etc/portage/package.mask, $PORTDIR/profiles/package.mask или package.mask в вашем профиле. Portage называет это "маскировкой package.mask".

**\[m\]4.1.4**

Версия совпадает с локальной маской (из /etc/portage/package.mask), но не замаскирована ни профилем, ни $PORTDIR/profiles/package.mask.

**{P}2.95.3-r8**

Первоначально версия была замаскирована профилем, но эта маскировка была локально изменена в /etc/portage/profile/packages.

**{M}4.0.0\_alpha20050213**

Первоначально версия была замаскирована $PORTDIR/profiles/package.mask, но эта маскировка была локально изменена в /etc/portage/package.unmask.

\***3.3.3**

Версия "замаскирована отсутствующим ключевым словом", но стабильна на других архитектурах.

**~\*3.3.3**

Версия замаскирована отсутствующим ключевым словом и нестабильна на других архитектурах.

**\*\*3.3.3**

Версия замаскирована отсутствующим ключевым словом для всех архитектур.

**(\*\*)3.4.3-r2**

Первоначально версия не имела ключевого слова, но этот параметр был локально изменен (в /etc/portage/package.keywords или путем редактирования переменной ACCEPT\_KEYWORDS).

**-\*3.4.3-r2**

Версия "замаскирована ключевым словом -\*" для всех архитектур (в скором времени это обозначение перестанет поддерживаться).

**-0.8.14**

Версия замаскирована -ARCH.

**~3.3.5.20050130**

Версия замаскирована ключевым словом ~keyword.

**(~)3.3.5.20050130**

Первоначально версия была замаскирована ключевым словом ~keyword, но эта маскировка была локально изменена (в /etc/portage/package.keywords или путем редактирования переменной ACCEPT\_KEYWORDS).

**\[M\]~1.0.9626**

Версия замаскирована одновременно package.mask и ключевым словом ~keyword.

**\[m\](~)4.1.4-r1**

Первоначально версия была замаскирована только ключевым словом ~keyword, но эта маскировка была локально изменена (в /etc/portage/package.keywords или путем редактирования ACCEPT\_KEYWORDS). Тем не менее версия замаскирована локально (в /etc/portage/package.mask).

**3.3.1**

Наконец, эта запись обозначает стабильную версию; она стабильна и без локальных настроек.

### eix-diff[¶](#-eix-diff)

Вывод утилиты **eix-diff** полностью определяется переменными конфигурации (**DIFF\_FORMAT\_NEW**, **DIFF\_FORMAT\_DELETE**, **DIFF\_FORMAT\_CHANGED** и a множество других переменных, к которым - по крайней мере, при стандартных настройках - обращаются перечисленные посредством отложенной замены. См. ниже.) Таким образом, ниже на примерах мы показываем только стандартное поведение текущей версии eix. Хотя этот стандартный формат уже довольно давно не меняется, в новых версиях eix мы не можем гарантировать стабильности настроек по умолчанию.

**\[N\] \>\> foo/bar (~1.0): description of foo/bar**

В дереве портежей появился свежий пакет **foo/bar**.

**\[\*N\] \>\> foo/bar (1.0): description of foo/bar**

В дереве портежей появился свежий пакет **foo/bar**. Кроме того, он имеет версию (1.0), которая может быть установлена без размаскировки или изменения ключевых слов.

**<< foo/bar ({M}1.0): description of foo/bar**

Пакет **foo/bar** был удален из дерева портежей; предыдущая версия, **1.0**, ранее была замаскирована, но сейчас уже не замаскирована (вероятно, потому, что разработчик при удалении пакета удалил файл package.mask).

**\[\*\>\] == foo/bar (1.0): description of foo/bar**

Статус пакета **foo/bar** в дереве портежей изменился (для ваших настроек): для него появилась версия (1.0), которая может быть установлена без размаскировки и изменения ключевых слов, в то время как ранее foo/bar такой версии не имел. Кроме того, символ **\>** означает, что один слот получил более новую версию. В данном случае появление и **\>**, и **\*** вызвано одним и тем же изменением.

**\[\><\] == foo/bar (1.1(1) 2.0(2) -\> 1.0(1) 2.1(2)): description**

Статус пакета **foo/bar** в дереве портежей изменился (для ваших настроек): символы в левой части строки означают, что один слот получил более новую версию пакета, которая может быть установлена без размаскировки и изменения ключевых слов, а из другого слота эта новая версия была удалена. Если вы посмотрите на версии, то увидите, что слот **2** получил новую версию (предыдущая стабильная версия в этом слоте была **2.0**, теперь **2.1**), а версия, которая до этого была последней, **1.1**, была удалена из слота **1** или замаскирована (текущая стабильная версия в этом слоте - **1.0**).

**\[UD\] == foo/bar (1.1(1)@01.01.2009; 1.1(1) -\> 2.0(2)): description**

Статус пакета **foo/bar** в дереве портежей изменился (для ваших настроек): символы в левой части строки означают, что единственный установленный слот может быть обновлен (без изменения масок/ключевых слов), а другой слот, в который производилась установка, был удален/замаскирован. Версии, указанные в правой части строки, показывают, что установленная версия **1.1** в слоте **1** была удалена или замаскирована, а другой установленной версии в **1** нет. Однако в слоте **2** появилась новая стабильная версия (слот **2** ранее не существовал или не имел стабильной версии).

Поскольку еще ни одна версия не была установлена в слот **2**, eix в этой ситуации не может определить, уместно ли обозначение "**U**". Ведь eix не отслеживает зависимости и поэтому не знает, будет ли использован новый слот, например, world-файлом, или же существует только некоторая зависимость со старым слотом. Поэтому символ "**U**" в этом случае будет отображен только если выставлено значение **UPGRADE\_TO\_HIGHEST\_SLOT=true** или если пакет фигурирует в **/etc/portage/package.slot\_upgrade\_allow**.

Вывод вида **== foo/bar ...** был бы, на самом деле, более логичным, поскольку дополнительно один слот приобрел новую стабильную версию, а из другого слота была удалена версия, до бывшая до того времени новейшей стабильной. Однако, поскольку "**U**" или, соответственно, "**D**" это и так подразумевают, разработчики приняли решение по умолчанию никогда не отображать символы **<** и **\>**, если имеется обозначение **U** или **D**. Разумеется, вы вправе изменить это поведение, создав собственную строку **DIFF\_FORMAT\_HEADER\_CHANGED**.

## FORMATSTRING[¶](#FORMATSTRING)

Строка формата может содержать условные блоки, свойства пакетов, настройки цветного вывода и стандартные строки. Если для какого-либо пакета строка формата занимает часть пустой строки, отображается и завершающий переход на новую строку. Таким образом, вы можете заключить всю строку формата в условный блок, чтобы выводились только те пакеты, которые соответствуют условию. Ниже будет приведен пример такого сценария-обертки.

### Условные блоки[¶](#-Условные-блоки)

Принцип действия условий прост: расширяется какое-либо свойство, и результирующая строка сопоставляется с другой строкой. Если они совпадают, условие признается истинным и выполняются команды в блоке. С условиями можно использовать отрицание, чтобы, когда условие истинно, выполнялись команды из части "else", а когда оно ложно - команды из части "if". Часть "else" может не выполняться вовсе.

**{**\[**!**\]_СВОЙСТВО_\[**=**_RHS_'**\]**}_TCODE_{}

Если строка, полученная в результате развертывания _СВОЙСТВа_, совпадает с _RHS_, выполнить _TCODE_. Символ **!** обозначает отрицание действия. _RHS_ представляет собой либо свойство (если заключен в <\>), либо переменную (если имеет префикс $), либо строку (если заключен в кавычки или не сопровождается никакими служебными символами).

**{**\[**!**\]_СВОЙСТВО_\[**=**_RHS_\]**}**_TCODE_**{else}**_FCODE_**{}**

Если строка, полученная в результате развертывания _СВОЙСТВа_, совпадает с _СТРОКОЙ_, выполнить _TCODE_. Иначе выполнить _FCODE_.

_СВОЙСТВО_ может быть либо одним из свойства пакетов, описанных ниже, либо обращением к переменной. Обращение к переменной имеет вид **$**_ПЕРЕМЕННАЯ_. Нет необходимости инициализировать эту _ПЕРЕМЕННую_ : по умолчанию она содержит пустую строку.

Для изменения _ПЕРЕМЕННой_ исполняемой среды используйте следующий синтаксис:

**{**\[**!**\]**\***_ПЕРЕМЕННАЯ_\[**=**_RHS_**\]**}

Значением переменной исполняемой среды **ПЕРЕМЕННАЯ** станет _СТРОКА_. С **!** результат будет либо пустым, либо равным 1, в зависимости от того, пуста или непуста _СТРОКА_. Если опущена завершающая часть (включая символ **=**), блок получает особое значение: **{\*I<ПЕРЕМЕННАЯ}** устанавливает значением _ПЕРЕМЕННой_ единицу, **{!\*I<ПЕРЕМЕННАЯ**}\> устанавливает значением _ПЕРЕМЕННой_ пустую строку.

### Свойства пакетов[¶](#-Свойства-пакетов)

Имена, которые соответствуют отдельным свойствам обрабатываемого пакета. Если вы используете имя для вывода свойства, оно **должно быть заключено в "уголки"** (т.е. иметь вид "<имя\>").

**name**, **category**, **homepage**, **licenses**

Соответственно название, категория, веб-страница проекта текущего пакета и лицензии, под которыми он распространяется.

**availableversions:**_ПЕРЕМЕННАЯ_, **availableversions:**_ПЕРЕМЕННАЯ_:_СЛОТЫ\_ПЕРЕМЕННЫХ_

Для каждой версии выводится содержимое переменной конфигурации/окружения с именем _ПЕРЕМЕННАЯ_; оно интерпретируется как строка формата. При использовании второго типа синтаксиса и если хотя бы один слот пакета непуст, вместо _ПЕРЕМЕННой_ работают _СЛОТЫ\_ПЕРЕМЕННЫХ_, а версии сортируются по слотам.

На всякий случай уточним: требуемый формат нельзя указывать непосредственно после двоеточия; вместо этого необходимо сохранить его в новой переменной. _ПЕРЕМЕННАЯ_ и _СЛОТЫ\_ПЕРЕМЕННЫХ_ - всего лишь их имена.

Полезными примерами _ПЕРЕМЕННой_ являются **NAMEVERSION**, **EQNAMEVERSION**, **EQNAMEVERSION**, **ANAMESLOT**, **ANAMEASLOT**, **NAMESLOT**, **NAMEASLOT**, **DATESORT**. **ANAMESLOT** и **ANAMEASLOT** предназначены для использования во втором типе синтаксиса, т.е. в конструкциях **availableversions:ANAMESLOT:ANAMESLOT** или **availableversions:ANAMEASLOT:ANAMEASLOT** (Легко запомнить: **A**SLOT отображает слот всегда (**a**lways)). **NAMESLOT**, **NAMEASLOT** и **DATESORT** имеют смысл только для установленных версий. Подробнее об этих переменных читайте, выполнив **eix --dump**.

**markedversions:**_ПЕРЕМЕННАЯ_, **markedversions:**_ПЕРЕМЕННАЯ_:_СЛОТЫ\_ПЕРЕМЕННЫХ_

Аналогично **availableversions** с той разницей, что будут выведены только маркированные версии.

**bestversion:**_ПЕРЕМЕННАЯ_, **bestversion\*:**_ПЕРЕМЕННАЯ_, **bestslotversions:**_ПЕРЕМЕННАЯ_, **bestslotversions\*:**_ПЕРЕМЕННАЯ_, **bestslotupgradeversions:**_ПЕРЕМЕННАЯ_, **bestslotupgradeversions\*:**_ПЕРЕМЕННАЯ_

Аналогично **availableversions** с той разницей, что будет выведена только лучшая/-ие версия/-ии в каждом слоте. При использовании конструкций с символом **\*** в вывод включаются и нестабильные версии. При использовании конструкций, включающих **upgrade**, обрабатываться будут только те версии, которые должны появиться после обновления.

**installedversions:**_ПЕРЕМЕННАЯ_

Аналогично **availableversions** с той разницей, что будут выведены только установленные версии.

**installedmarkedversions:**_ПЕРЕМЕННАЯ_

Аналогично **installedversions** с той разницей, что будут только маркированные версии.

**first**, **last**, **slotfirst**, **slotlast**, **oneslot**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Вы можете использовать эти флаги, чтобы выяснить, первую или последнию версию пакета вы просматриваете (как правило, это бывает полезно, если вам необходим вывод какого-либо дополнительного текста). Аналогично, если вывод сортируется по слотам, вы можете проверить, первая или последняя версия в слоте отображается; возможно, существует всего один слот. Если условие удовлетворено, все эти свойства пусты, иначе их значение - 1\. Чтобы было удобнее повторно использовать код, когда вывод сортируется по слотам, переменная **slotfirst**/**slotlast** эквивалентна **first**/**last**, а значение **oneslot** равно 1\.

**slot**, **isslot**, **overlayver**, **overlaynum**, **versionkeywords**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Будет выведен текущий слот, оверлей или полные ключевые слова для текущей версии. Переменная **overlayver** пуста, если пакет целиком из одного оверлея; в этом случае, чтобы увидеть оверлей, следует использовать **overlay**. **overlaynum** же содержит номер оверлея; не поддерживает цветной вывод (если пакет не из оверлея, переменная пуста). Формат вывода **versionkeywords** обусловлен значениями переменных **FORMAT\_BEFORE\_KEYWORDS**, **FORMAT\_AFTER\_KEYWORDS**, **PRINT\_EFFECTIVE\_KEYWORDS**, **FORMAT\_BEFORE\_EFFECTIVE\_KEYWORDS**, **FORMAT\_AFTER\_EFFECTIVE\_KEYWORDS**. **isslot** позволяет выяснить, не пуст ли слот, и в этом случае возвращает 1, в противном случае не возвращает ничего.

**isbestupgrade**, **isbestupgrade\***, **isbestupgradeslot**, **isbestupgradeslot\***

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Если текущая версия является лучшей или, соответственно, лучшей в текущем слоте для обновления, будет возвращена единица. При использовании конструкций, включающих символ **\***, в обработку будут включены нестабильные версии.

**installedversion**, **markedversion**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Возвращает 1, если текущая версия установлена или, соответственно, маркирована, иначе возвращает пустую строку.

**ishardmasked**, **washardmasked**, **isprofilemasked**, **wasprofilemasked**, **ismasked**, **wasmasked**, **isstable**, **wasstable**, **isunstable**, **wasunstable**, **isalienstable**, **wasalienstable**, **isalienunstable**, **wasalienunstable**, **ismissingkeyword**, **wasmissingkeyword**, **isminuskeyword**, **wasminuskeyword**, **isminusunstable**, **wasminusunstable**, **isminusasterisk**, **wasminusasterisk**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Возвращает 1, если текущая версия стабильна в локальной конфигурации или, соответственно, в конфигурации по умолчанию, иначе возвращает пустую строку.

**isbinary**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Если существует соответствующий версии \*.tbz2-архив, возвращает 1, если архив не существует, возвращает пустую строку.

**restrict**, **restrictfetch**, **restrictmirror**, **restrictprimaryuri**, **restrictbincheck**, **restrictstrip**, **restricttest**, **restrictuserpriv**, **restrictinstalledsources**, **restrictbindist**, **restrictparallel**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Если для версии включен какой-либо из атрибутов **RESTRICT**, возвращает 1, если нет, возвращает пустую строку.

**properties**, **propertiesinteractive**, **propertieslive**, **propertiesvirtual**, **propertiesset**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Если для версии включен какой-либо из атрибутов **PROPERTIES**, возвращает 1, если нет, возвращает пустую строку.

**haveuse**, **use**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Отображает информацию сообразно значениям переменной **IUSE** (для доступных версий) или **USE** (для установленных версий). **haveuse** можно использовать для проверки, будет ли вывод непустым (тогда возвращает 1, иначе пустую строку). Для доступных версий **use** выводит переменную **IUSE**. Для установленных версий **use** выводит **USE** -флаги и информацию о том, установлены ли они (если нет, содержимое переменных **FORMAT\_BEFORE\_SET\_USE**, **FORMAT\_AFTER\_SET\_USE**, **FORMAT\_BEFORE\_UNSET\_USE**, **FORMAT\_AFTER\_UNSET\_USE** выводится там, где это предусмотрено).

**date:**_ПЕРЕМЕННАЯ_

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Отображает дату установки; формат функции даты strftime() считывается из _ПЕРЕМЕННОЙ_.

**version**

Только если _ПЕРЕМЕННАЯ_ используется в контексте вывода версий. Выводит простую версию в текстовом формате.

**installed**, **best**, **best\***

Возвращает 1, если хотя бы одна версия пакета установлена или, соответственно, имеется лучшая стабильная/нестабильная версия пакета, иначе возвращает пустую строку.

**versionlines**

Если утилите был передан флаг --versionlines, возвращает 1, иначе возвращает пустую строку.

**slotsorted**

Если утилите был передан флаг --versionsort, возвращает 1, иначе возвращает пустую строку.

**color**

Если вывод поддерживает цвета/маркеры, возвращает 1, иначе возвращает пустую строку. Например, если вывод перенаправляется в терминал и явно не выставлена обратная опция, переменная будет пуста.

**setnames**, **allsetnames**

Имена всех локальных сетов, которым принадлежит пакет, через пробел. При использовании **allsetnames** в обработку будет включен сет system.

**binary**

Если хотя бы для одной версии (доступной или установленной) имеется соответствующий ей \*.tbz2-архив, возвращает 1, иначе пустую строку. См. примечания к опции **--binary**.

**overlaykey**

Если все версии находятся в одном оверлее, значение "\[overlaykey\]" будет выведено с поддержкой цвета.

**system**

Если пакет существует в системном профиле или является виртуалом пакета из системного профиля, переменная получает значение 1\.

**world**

Если пакет фигурирует в world-файле или является виртуалом пакета из world-файла, переменная получает значение 1\.

**world\_sets**

Если пакет принадлежит world-сетам или является виртуалом пакета из world-сетов, переменная получает значение 1\.

**systempure**

Если пакет существует в системном профиле, переменная получает значение 1\.

**worldpure**

Если пакет фигурирует в world-файле, переменная получает значение 1\.

**world\_setspure**

Если пакет принадлежит world-сетам, переменная получает значение 1\.

**provide**

Строка PROVIDE для пакета.

**marked**

Если пакет был передан утилите с опцией **--pipe**, переменная получает значение 1\. Обычно это имеет смысл только для проверки.

**havemarkedversion**

Если хотя бы одна доступная версия пакета маркирована, возвращает 1, иначе пустую строку. Имейте в виду, что пакет может оказаться маркирован, при том что не маркирована ни одна из его версий.

**slots**, **slotted**

Если имеется как минимум два слота или, соответственно, как минимум один непустой слот, переменная получает значение 1\.

**colliuse**, **havecolliuse**

Набор IUSE-флагов (т.е. все флаги вместе взятые) для всех доступных версий пакета, через пробел. Переменная **havecolliuse** получает значение 1, если **colliuse** непуста; она работает быстрее, чем colliuse.

**haveversionuse**

Для экономии памяти и/или дискового пространства eix можно собирать без поддержки **IUSE** -флагов для каждой отдельно взятой версии. Если текущий пакет взят из такой базы данных или если eix был скомпилирован без учета этой информации, будет возвращена пустая строка, иначе 1\. Даже если проверка дала отрицательный результат, вы можете использовать синтаксис **use:...**, как описано выше. В этом последнем случае, однако, переменная окажется пуста.

**havebest**, **havebest\***

Если пакет имеет лучшую стабильную или, соответственно, нестабильную версию, переменная получает значение 1\.

**upgrade**, **upgradeorinstall**, **downgrade**, **recommend**, **recommendorinstall**

**upgrade** получает значение 1, если пакет установлен и как минимум один слот может быть обновлен (или если лучшая стабильная версия занимает новый слот, а значение переменной **UPDATE\_TO\_HIGHEST\_SLOT** - true). Другие переменные из этого ряда аналогичным образом проверяют, может ли пакет быть обновлен или установлен заново, следует ли откатить его до более ранней версии, может/должно ли быть произведено обновление/откат, может/должно ли быть произведено обновление/откат/установка, соответственно. Переменная **RECOMMEND\_LOCAL\_MODE** определяет, подчиняется ли описанная проверка **LOCAL\_PORTAGE\_CONFIG**.

**bestupgrade**, **bestupgradeorinstall**, **bestdowngrade**, **bestrecommend**, **bestrecommendorinstall**

Как в предыдущем случае, с той разницей, что во внимание принимается только лучшая стабильная версия пакета (а не все слоты).

**better**, **worse**, **differ**, **bestbetter**, **bestworse**, **bestdiffer**

Могут использоваться только в условных выражениях внутри **DIFF\_FORMAT\_CHANGED**. **better** получает значение 1, если новый пакет имеет новый слот или новую стабильную версию (или прежнюю версию, но из другого оверлея) в любом слоте. **worse** ведет себя аналогично в том случае, если прежняя версия имеет как минимум один лучший слот или слот, недоступный для нового пакета. **differ** возвращает единицу в том случае, если не все лучшие стабильные слоты прежних и новых пакетов совпадают. Соответствующие **best\*** -версии ведут себя аналогично с той разницей, что учитываются только лучшие стабильные версии (а не все слоты). Переменная **RECOMMEND\_LOCAL\_MODE** определяет, подчиняется ли проверка настройкам переменной **LOCAL\_PORTAGE\_CONFIG**.

**old...**, **new...**

Могут использоваться только внутри **DIFF\_FORMAT\_CHANGED**. Любое свойство может получить префикс **old** или **new** и соответствующее этому свойству значение, но с учетом, соответственно, прежних или новых данных. Если префикса **old** или **new** нет, по умолчанию принимается новая версия. Например, конструкция **oldavailableversions:ПЕРЕМЕННАЯ** выведет предыдущие доступные версии (ПЕРЕМЕННАЯ при этом определяет формат вывода), а **newavailableversions:ПЕРЕМЕННАЯ** и **availableversions:ПЕРЕМЕННАЯ** выведут доступные версии текущего (т.е. нового) пакета.

### Цвета вывода[¶](#-Цвета-вывода)
(_ИМЯ_,_ЯРКОСТЬ_;_МАРКЕРЫ_)

Последовательность ",_ЯРКОСТЬ_" и/или ";_МАРКЕРЫ_" может быть опущена.

При _ЯРКОСТи_, равной 1, eix будет использовать для _ИМени_ соответствующий 'яркий' (насыщенный) цвет ; если _ЯРКОСТЬ_ равна 0 - стандартный цвет.

Пустое _ИМЯ_ соответствует значению default, и, в отличие от значения none, возвращает вывод к стандартным настройкам цвета, без маркеров.

Пустое значение (или отсутствие) _МАРКЕРов_ соответствует значению none, т.е. изменения атрибутов не происходит. Можно одновременно указывать несколько атрибутов маркировки (через запятую).

Доступные цвета: _default (по умолчанию), none (нет), black (черный), red (красный), green (зеленый), yellow (желтый), blue (синий), purple (лиловый), cyan (ультрамарин), gray (серый)_.

Доступные атрибуты маркировки: _none (нет), bold (жирный), underline (подчеркивание), blink (мигание), inverse (негатив)_.

### Примеры:[¶](#-Примеры)

**FORMAT='{installed}(yellow,1;underline){else}(yellow,0){}<name\>()}\\n' eix ...**

Если пакет **...** установлен, выводит его имя ярким желтым цветом с подчеркиванием, иначе обычным желтым цветом.

**FORMAT='<category\>/<name\><installedversions:INSTFORMAT\>\\n' INSTFORMAT='{first}:{}<version\><date:DATEFORMAT\>{!last}\\n\\t{}' DATEFORMAT='%x' eix autom\***

Для каждого пакета **autom\*** выводит имя с указанием категории, а если пакет установлен, то и установленные версии и соответствующие им даты установки. Тот же результат можно было бы получить, вместо **\\t\\n{}** поставив **:{else}\\t\\n{}**, поскольку в конце каждой версии, кроме последней, и в начале каждой версии, кроме первой, выводится, разумеется, одна и та же последовательность **\\t\\n**.

**FORMAT='{downgrade}%{FORMAT\_ALL}{}' eix -I**

Будут выведены все установленные пакеты, которые рекомендуется откатить до более ранних версий. Заметьте, что конструкция **FORMAT='{downgrade}%{FORMAT}{}'** не работает, поскольку в этом случае в отложенной замене возникает определение со ссылкой на само себя; естественно, переменную нельзя определять значением самой этой переменной. Поэтому начиная с версии eix 0.13.4 содержимое **FORMAT** и других подобных ей переменных значительно упростилось: **%{FORMAT\_ALL}** (для других родственных переменных аналогично). Таким образом, вы можете свободно вставлять полное определение исходного значения **FORMAT** (что мы и сделали в приведенном примере).

Обратите внимание: если вы хотите представить предыдущий пример в компактном выводе, вы не можете просто добавить опцию **-c** - единственным эффектом, которого вы добьетесь, будет то, что для определения строки формата будет использована переменная **FORMAT\_COMPACT**, а не **FORMAT**. Для того, чтобы действительно получить компактный вывод, используйте либо:
**FORMAT\_COMPACT='{downgrade}%{FORMAT\_ALL\_COMPACT}{}' eix -Ic**

либо (что еще проще):

**FORMAT='{downgrade}%{FORMAT\_ALL\_COMPACT}{}' eix -I**

## ФАЙЛЫ[¶](#ФАЙЛЫ)

### /etc/eix-sync.conf[¶](#-etceix-syncconf)

В данном файле хранятся команды и настройки, применяемые к сценарию **eix-sync**. Комментарии в нем начинаются с символа **\#** (строки обрезаются при первом вхождении **\#**; с **\#** нельзя использовать маски). Строки могут иметь описанный ниже вид и исполняются в заданном порядке перед вызовом **emerge --sync**.

Обратите внимание, что к этому файлу добавляется содержимое переменной **EIX\_SYNC\_CONF**. По умолчению она расширена на **EIX\_SYNC\_OPTS**, так что значения этой переменной также добавляются в файл. Обе упомянутые переменные могут использоваться для переопределения настроек по умолчанию, указанных в **/etc/eix-sync.conf**. При выполнении **eix-sync** анализируется большая часть этих строк, поэтому необходимо учитывать требования безопасности!

_опция/-ии_

Использовать _опцию/-ии_ по умолчанию для eix-sync (ставится перед всеми остальными опциями). В общем случае _опции_ должны начинаться с символа "**-**". _опции_ анализируются оболочкой внутри сценария **eix-sync**, поэтому обратите внимание на безопасность и убедитесь, что разделители команд оболочки правильно оформлены кавычками!

_Имя_

Вызвать команду **layman -s** _Имя_. Утилита **layman** предназначена для синхронизации оверлеев и доступна в портежах как **app-portage/layman**.

**\***

Вызвать **layman -S** (т.е. синхронизировать оверлеи с помощью layman).

**!**_команда_

Анализировать _команду_ внутри сценария оболочки **eix-sync** (в той же оболочке). _команда_ должна успешно завершить работу, в противном случае **eix-sync** сделает останов и выдаст ошибку. (Таким образом, конструкция **!layman** _Имя_ практически идентична записи _Имя_.) Если вы хотите, чтобы статус выхода игнорировался, пишите в конце команды "; true".

Вы можете использовать данную функцию для распаковки оверлея перед вызовом **layman** или для внесения локальных изменений после вызова **layman**.

В последних версиях eix _команда_ уже ничего не выводит (если вам необходим вывод, используйте einfo) и не анализируется в подоболочке. Иными словами, при необходимости вы можете свободно редактировать переменные окружения, начинать/завершать перенаправление. Недостаток такого поведения состоит в том, что не менее легко и допустить ошибку: переопределить внутренние переменные или функции eix-sync. Если вы опасаетесь что-либо нарушить, заключайте команду в скобки (...), чтобы она запускалась в подоболочке.

**!!**_команда_

Аналогично записи **!** _команда_ с той разницей, что в данном случае _команда_ будет выполнена в любом случае, даже при использовании опций -d, -u, -l. Это позволяет устанавливать переменные окружения для других программ.

**~**_команда_

Имеет смысл только при использовании eix-sync опций **-s** и **-2**. В таком случае _команда_ будет выполнена перед первым вызовом **rsync**; вывод _команды_ анализируется внутри оболочки **eix-sync**. Если _команда_ или анализ ее вывода отрабатывают с ошибкой, **eix-sync** перестанет выполняться и выдаст сообщение об ошибке. Это можно использовать, например, чтобы выполнить **keychain** и возвратить содержимое соответствующего файла _~/.keychain/\*-sh_, либо для возвращения команд экспорта для текущих переменных **SSH\_AUTH\_SOCK** и **SSH\_AGENT\_PID**. Допускается также вывод _команды_ в виде команды, изменяющей значения переменных **PORTAGE\_RSYNC\_OPTS**, **PORTAGE\_RSYNC\_EXTRA\_OPTS**, **PORTDIR**, **PORTDIR\_SERVER**, **PORTDIR\_CLIENT**, **SERVER**, **CLIENT**. При вызове _команды_ данные переменные получат значения по умолчанию и в дальнейшем будут использованы для команд **rsync** с их очевидным значением.

**@**_команда_

Добавить привязку к _команде_; фактическое выполнение _команды_ будет отложено до вызова **emerge --sync** (успешного).

**@@**_команда_

Добавить привязку к _команде_; фактическое выполнение _команды_ будет отложено до вызова **emerge --sync** (успешного) с последующим **eix-update**.

Вот **примерная** последовательность привязок/команд:

привязки **!!**

**cp /var/cache/eix /var/cache/eix.previous**

вызов layman, привязки **!** в порядке, указанном в /etc/eix-sync.conf

привязки **~**

**emerge --sync**

привязки **@**

**eix-update**

привязки **@@**

**eix-diff /var/cache/eix.previous**

Несколько полезных примеров вы найдете в **/etc/eix-sync.conf**:

**-C --ignore-default-opts**

Используйте эту строку, если у вас включена опция --ask в переменной EMERGE\_DEFAULT\_OPTS в файле /etc/make.conf, но вы не хотите, чтобы при выполнении eix-sync было затребовано подтверждение операции.

**-r -M**

Используйте эти параметры, если у вас **PORTDIR\_CACHE\_METHOD=assign**, а функция **FEATURES=metadata-transfer** неактивна или (по умолчанию в последних версиях portage) отключена. При необходимости вы можете также использовать **-r** и **-M** по отдельности или заменить **-M** строкой.

**@emerge --regen**

Запускать **emerge --regen** вместо **emerge --metadata**.

**@egencache --repo=local --update**

Обновлять кэш метаданных оверлея с именем репозитария local между вызовами eix-update и emerge --sync. Это имеет смысл в том случае, если для данного оверлея используется метод кэширования **metadata-flat**, и вы хотите убедиться, что кэш метаданных обновлен. Побочным эффектом этого поведения является то, что команда **egencache** будет выполняться даже в том случае, если репозитарий не изменился (так обычно и происходит с локальными репозитариями).

**!egencache --repo=foo --update**

Обновить кэш метаданных оверлея с именем репозитария foo. Это имеет смысл в том случае, если ранее у вас была строка **foo** или **!команда для обновления foo**, призванная обеспечить обновление репозитария (будь то с помощью layman или какой-либо другой утилиты), а вы хотите использовать для этого оверлея метод кэширования **metadata-flat**, несмотря на то, что кэш метаданных содержит ошибки или не существует в данном репозитарии.

**!!exec \>/var/log/eix-sync.log ; chown portage: /var/log/eix-sync.log || true**

Направить вывод в журнал (с соответствующими правами). true в конце обозначает, что выполнение сценария будет продолжено принудительно даже в том случае, если chown выдает ошибку. Если вы не хотите перенаправлять вывод конечного **eix-diff**, вам следует использовать эту конструкцию в связке со следующей:

**@@exec \>/dev/tty**

Отображать статистику выполнения **eix-diff** в терминале, даже если было сделано перенаправление.

**@@exit 0**

Не выполнять **eix-diff**.

**!!export FORCE\_USECOLORS= ${FORCE\_USECOLORS:-true}**

Если только переменная FORCE\_USECOLORS не определяет иное для вашего окружения, вывод eix будет цветным даже в случае перенаправления.

**~keychain --quiet ~/.ssh/id\_rsa ; cat ~/.keychain/ \`hostname\`-sh**

**@@eix-remote update **\* \`portageq portdir\`/local/layman/eix-caches.tar.bz2 \*

(Если вам не нужна локальная копия данных из каталога /usr/portage/local/layman, последний аргумент можно опустить.)

**@eix-remote fetch /var/cache/remote-cache.tbz2**

**@@eix-remote add /var/cache/remote-cache.tbz2**

### /etc/eixrc[¶](#-etceixrc)

Глобальный конфигурационный файл eix. Значения переменных в **~/.eixrc** или в окружении могут переопределять переменные, определенные в этом файле. См. **~/.eixrc**.

### EIXRC[¶](#-EIXRC)

Если эта переменная окружения установлена, то ее значение будет использовано вместо /etc/eixrc при обращении к данным конфигурации. В таком случае содержимое файла ~/.eixrc будет проигнорировано (но вы, разумеется, можете указать явно, что должны использоваться его значения, если это необходимо).

### EIX\_SYNC\_OPTS, EIX\_SYNC\_CONF, EIX\_REMOTE\_OPTS, EIX\_LAYMAN\_OPTS, EIX\_TEST\_OBSOLETE\_OPTS[¶](#-EIX_SYNC_OPTS-EIX_SYNC_CONF-EIX_REMOTE_OPTS-EIX_LAYMAN_OPTS-EIX_TEST_OBSOLETE_OPTS)
Хотя эти переменные обычно настраиваются в ~/.eixrc (описаны в соответствующем разделе), мы упоминаем их здесь, поскольку они чрезвычайно важны для безопасности. Они (по крайней мере некоторые) анализируются оболочкой, если вы запускаете сценарии с соответствующим именем. Поэтому вы непременно должны убедиться, что при запуске этих сценариев из-под root'а переменные не будут изменены. 

### ~/.eixrc[¶](#redpre450nt)

Пользовательский файл конфигурации. Переменные в этом файле могут быть переопределены переменными окружения. Для присвоения им значений вы можете использовать shell-подобный синтаксис. Вы можете подключать и другие файлы, использовать вспомогательные переменные для настройки.

Если вы используете вспомогательные переменные обычным образом, вы можете только просматривать заменяемые значения с помощью --dump или --dump-defaults и не можете заменять подставляемые значения, например, в окружении.

Таким образом, вы можете обращаться к переменным не только используя обычный синтаксис оболочки, но и с помощью конструкции **%{**_ПЕРЕМЕННАЯ_**}** (скобки можно опускать). Это означает, что замена будет отложена до того момента, когда все файлы конфигурации и переменные среды будут обработаны. Отложенная замена не отображается при использовании опций with --dump или --dump-defaults.

Такое поведение именуется отложенной заменой / отложенным обращением и предоставляет несколько дополнительных возможностей:

**Специальные символы для отложенной замены**

**%{%**

Требуется в случае, если вам необходимо использовать в переменной **%{** (в противном случае произойдет отложенная замена).

**\***_ПЕРЕМЕННАЯ_

Если отложенное обращение использует имя переменной, начинающееся с **\***, символ **\*** заменяется на **EIX\_** или **DIFF\_**, в зависимости от того, вызывается ли переменная из **eix**/**eix-update** или из **eix-diff**. Это позволяет иметь различные настройки по умолчанию для этих программ.

Так, отложенное обращение **%{\***_ПЕРЕМЕННАЯ_**}** подставит расширенное значение **EIX\_**_ПЕРЕМЕННАЯ_ или **DIFF\_**_ПЕРЕМЕННАЯ_, сооветственно.

Атрибуты **\\** и **\*** могут быть совмещены (порядок не имеет значения).

**\\**_ПЕРЕМЕННАЯ_

Если отложенное обращение использует имя переменной, начинающееся с **\\**, все символы \\ символы \[\\n\\r\\t \] в значении (расширенной) _ПЕРЕМЕННой_ рассматриваются как экранированные.

Так, отложенное обращение **%{\\**_ПЕРЕМЕННАЯ_**}** может быть использовано в таких переменных как **CACHE\_METHOD** или **EIX\_LOCAL\_SETS**; это гарантирует, что _ПЕРЕМЕННАЯ_ имеет не более одной "необработанной" записи, даже если она содержит пробелы или обратный слэш.

Атрибуты **\\** и **\*** могут быть совмещены (порядок не имеет значения).

**Условные блоки в отложенных обращениях**

Если вы хотите заменять значения нескольких переменных совершенно иным образом, в зависимости от статуса определенной переменной (булевой), вы можете использовать условные блоки.

В известной степени их функционирование здесь аналогично поведению условных блоков в FORMATSTRING: если переменная, к которой происходит обращение, наконец получает булево значение true (**true**/**1**/**yes**/**y**/**on**) (или, соответственно, любое непустое значение, если _ПЕРЕМЕННАЯ_ имеет префиксом дополнительный символ **?**), в результате будет возвращено значение true, и соответствующий блок строки будет расширен. Можно использовать отрицание условий, чтобы расширялась часть "else", когда условие истинно, и часть "if", когда условие ложно. Часть "else" может не выполняться вовсе. Допустимо использовать особые имена переменных: **\***_ПЕРЕМЕННАЯ_ вместо _ПЕРЕМЕННАЯ_.

**%{?**_ПЕРЕМЕННАЯ_**}**_TCODE_**%{}**

Расширить _TCODE_, если _ПЕРЕМЕННАЯ_ получает значение true.

**%{??**_ПЕРЕМЕННАЯ_**}**_TCODE_**%{}**

Расширить _TCODE_, если _ПЕРЕМЕННАЯ_ получает значением непустую строку.

**%{!**_ПЕРЕМЕННАЯ_**}**_TCODE_**%{}**

Расширить _TCODE_, если _ПЕРЕМЕННАЯ_ получает значение false.

**%{!?**_ПЕРЕМЕННАЯ_**}**_TCODE_**%{}**

Расширить _TCODE_, _ПЕРЕМЕННАЯ_ получает значением пустую строку.

**%{?**_ПЕРЕМЕННАЯ_**}**_TCODE_**%{else}**_FCODE_**%{}**

Расширить _TCODE_, если _ПЕРЕМЕННАЯ_ получает значение true, иначе _FCODE_.

**%{??**_ПЕРЕМЕННАЯ_**}**_TCODE_**%{else}**_FCODE_**%{}**

Расширить _TCODE_, если _ПЕРЕМЕННАЯ_ получает значением непустую строку, иначе _FCODE_.

**%{!**_ПЕРЕМЕННАЯ_**}**_TCODE_**%{else}**_FCODE_**%{}**

Расширить _TCODE_, если _ПЕРЕМЕННАЯ_ получает значением false, иначе _FCODE_.

**%{!?**_ПЕРЕМЕННАЯ_**}**_TCODE_**%{else}**_FCODE_**%{}**

Расширить _TCODE_, если _ПЕРЕМЕННАЯ_ получает значением пустую строку, иначе _FCODE_.

Условный блок может и целиком помещаться в одной переменной. В этом случае будет невозможно, например, заменить символ **%{}** путем отложенного обращения к другой переменной (но в _TCODE_/_FCODE_ использование отложенных обращений допускается).

Заметьте, что все переменные, которые вы добавляете для отложенной замены, выводятся с помощью опции --dump, только если они действительно используются (т.е. если к ним обращаются какие-либо другие переменные). Если вы хотите видеть их во всех случаях, например, для удобства комментирования или последующих изменений, вы можете собрать ссылки на них в переменной **DUMMY**.

Следующие переменные не содержат используемых только для отложенных обращений. Чтобы получить подробное описание этих последних переменных (и их стандартных настроек), выполните **eix --dump**.

**DUMMY (строка)**

Эта переменная не влияет напрямую на программы, но может быть использована для хранения отложенных обращений к переменным (не обрабатываемым иным образом), чтобы их можно было просмотреть с помощью --dump или --dump-defaults.

**EIX\_SYNC\_OPTS**, **EIX\_SYNC\_CONF** **(строка)**

Значение переменной **EIX\_SYNC\_CONF** добавляется в файл **@SYSCONFDIR/eix-sync.conf**. Подробности см. в описании этого файла. По умолчанию **EIX\_SYNC\_CONF** представляет собой отложенную замену для **EIX\_SYNC\_OPTS**, т.е. вы обычно можете использовать **EIX\_SYNC\_OPTS** в тех же целях. Помните, что если одна из этих переменных будет поставлена под угрозу, при вызове **eix-sync** с привилегиями администратора может произойти практически всё что угодно - подумайте о безопасности ! Если вы используете эти переменные, аккуратно расставляйте кавычки!

**EIX\_REMOTE\_OPTS**, **EIX\_LAYMAN\_OPTS**, **EIX\_TEST\_OBSOLETE\_OPTS** **(строка)**

Содержимое этих переменных анализируется и используется в качестве аргументов сценариями **eix-remote**, **eix-layman** и **eix-test-obsolete** соответственно. Поэтому не забывайте о рисках безопасности и всегда ставьте переменные в кавычки!

**EIXRC\_SOURCE** **(строка)**

Данный путь используется как префикс source-команд в /etc/eixrc. Стандартно он должен быть определен в окружении, но может быть определен и в файле /etc/eixrc. В последнем случае он переопределит значение переменной окружения непосредственно при обработке, пока всем файлам не будут сопоставлены источники. Обратите внимание, что в момент считывания значения переменной отложенная замена еще не произведена.

**EIX\_PREFIX** **(строка префикса)** ("строка префикса" означает строку, но если она имеет значение '/', оно будет заменено на '')

Эта переменная предназначена главным образом для присвоения значения в окружении, если вы хотите использовать chroot. Она применяется как префикс пути, по которому ищется /etc/eixrc. Если этот путь не определен, служит префиксом значения переменной окружения **PORTAGE\_CONFIGROOT**. Если не определена и она, используется значение переменной по умолчанию (как правило, пустое).

Кроме того, данная переменная используется при отложенной замене для определения префикса путей других переменных; подробнее о переменных, которые к ней обращаются, см. в выводе **eix --dump**. При текущих настройках по умолчанию она изменяет все пути, за исключением:

**EPREFIX** **(строка префикса)**

Для этой переменной значение по умолчанию берется из EIX\_PREFIX; к нему добавляется умолчание, зависящее от конфигурации (для prefix-portage). Эта переменная не имеет собственного значения и используется при отложенной замене для определения префикса путей других переменных (если не изменены их значения по умолчанию); подробнее о переменных, которые к ней обращаются, см. в выводе **eix --dump**. При текущих настройках по умолчанию она изменяет все пути, за исключением:

**/usr/bin/eix-functions.sh**

**~/.eixrc**

**путь к файлу/-ам кэша**, переданный командной строке

**PORTAGE\_PROFILE** (переменная, но не ссылка)

**PORTDIR**

**Пути доступа к оверлеям**

Последние три могут быть изменены через **EPREFIX\_TREE**.

Переменная **EPREFIX** предназначена для обеспечения доступа, подобного chroot, к prefix-portage. Заметьте, что как пользователь prefix-portage вы должны будете выполнять eix-sync с опцией **-e**.

**ROOT** **(строка префикса)**

**EPREFIX\_TREE** **(строка префикса)**

**EPREFIX\_ROOT** **(строка префикса)**

На самом деле это не внутренние переменные eix - они просто используются для отложенной замены со следующими переменными, аналогично **EPREFIX** (см. ниже).

Для базового отслеживания использования portage данной переменной служит переменная **ROOT**. Заметьте, что переменные в файле /etc/make.conf не переопределяют переменные конфигурации eix. Так, команда **ROOT=**_что-либо_, прописанная в /etc/make.conf, никак не скажется на поведении eix. Если вам нужно обратное, установите новое значение в окружении или в конфигурационном файле eix.

Вы можете легко изменить пути, к которым относятся **EPREFIX** и **ROOT** : для этого просто используйте при определении соответствующих переменных отложенные обращения **%{EPREFIX}**, **%{ROOT}**, **%{EPREFIX\_ROOT}** (которые, в свою очередь, определяются как отложенное обращение, так что вы можете свободно переопределять поведение программы, в случае если и **EPREFIX**, и **ROOT** непусты: вы можете совместить эти два пути, а можете выбрать только один из них), или же не используйте ничего. Разумеется, для отложенного обращения вы можете назначать и другие переменные, например:

**EIX\_CACHEFILE= %{EPREFIX\_PROFILE}/var/cache/eix**

Используйте эту настройку, если вы хотите, чтобы файл кэша eix зависел от профиля администратора (и только от него).

**PORTAGE\_CONFIGROOT** **(строка префикса)**

Используется как префикс путей каталога /etc. Задача - сохранять PORTAGE\_CONFIGROOT аналогично тому, как это делает portage. Если вы определяете эту переменную в окружении, одновременно изменится и путь доступа к /etc/eixrc. (Заметьте, что обращение к файлу /etc/eixrc происходит до выполнения отложенной замены.)

**MAKE\_GLOBALS** **(строка)**

Если этот файл существует, он будет использован вместо **%{PORTAGE\_CONFIGROOT}/etc/make.globals**. Значение по умолчанию соответствует поведению \*portage-2.2\* и выше.

**EPREFIX\_SOURCE** **(строка префикса)**

Используется как префикс путей - аргументов source-команд в файлах /etc/make.conf и /etc/make.globals.

**EPREFIX\_INSTALLED** **(строка префикса)**

Используется как префикс пути, по которому eix ожидает информацию об установленных пакетах.

**EPREFIX\_PORTAGE\_CACHE** **(строка префикса)**

Используется как префикс пути к кэшу портежей.

**EPREFIX\_ACCESS\_OVERLAYS** **(строка префикса)**

Используется как префикс путей к оверлеям, для доступа к их файлам.

**EPREFIX\_PORTDIR** **(строка префикса)**

Используется как префикс **PORTDIR**.

**EPREFIX\_OVERLAYS** **(строка префикса)**

Используется как префикс всех записей в **PORTAGE\_OVERLAY**.

**EPREFIX\_PROFILE** **(строка префикса)**

Используется как префикс **PORTAGE\_PROFILE** (переменной, а не ссылки).

**EPREFIX\_VIRTUAL** **(строка префикса)**

Используется как префикс оверлеев в базе данных eix для проверки их существования.

**EIX\_CACHEFILE** **(строка)**

Файла кэша eix (обычно **%{EPREFIX}/var/cache/eix**).

**EIX\_WORLD** **(строка)**

Файл, который eix рассматривает как файл world. Учтите, что обычно этот файл доступен для чтения только в том случае, если вы входите в группу portage. Во избежание проблем с правами доступа можно использовать переменную **SAVE\_WORLD**.

**EIX\_WORLD\_SETS** **(строка)**

Файл, который eix рассматривает как файл world\_sets. Для него справедливо всё сказанное для **EIX\_WORLD**.

**EIX\_LOCAL\_SETS** **(список строк)**(что такое список строк, объясняется далее)

Это список каталогов, которые содержат локально определенные сеты. Каталоги считываются в заданном порядке; файлы с именами сетов, которые были обработаны ранее, игнорируются: в этом отношении предшествующие записи в **EIX\_LOCAL\_SETS** имеют приоритет над новыми.

Для относительных каталогов (т.е. каталогов, имена которых не начинаются с символа **/**) родительским считается **$PORTDIR**. Записи в **EIX\_LOCAL\_SETS**, начинающиеся со специального символа **\***, рассматриваются особо, как несколько записей; при этом символ **\*** последовательно заменяется путями доступа к оверлеям, в обратном порядке (это сделано потому, что в некотором смысле более ранние записи **EIX\_LOCAL\_SETS** переопределяют более поздние, в то время как для переменной **PORTDIR\_OVERLAY** программа ожидает обратного).

По умолчанию эта переменная содержит **/etc/portage/sets**, **/etc/portage/sets.eix**, **sets** (т.е., в общем, **${PORTDIR}/sets**, исходя из предыдущего абзаца), **\*/sets** (т.е., в общем, **${PORTIDR\_OVERLAY}/sets**, исходя из предыдущего абзаца), а также **%{EIX\_LOCAL\_SETS\_ADD}**. Последнее обращение позволяет вам добавлять дополнительные каталоги к значению переменной **%{EIX\_LOCAL\_SETS\_ADD}** в файле **/etc/eixrc**. Это может быть полезно, в частности, если вы определили другой каталог для множественных сетов (например, для оверлея или для обработки "world-candidate = False") в файле /etc/portage/sets.conf вашей системы или в файле sets.conf file какого-либо оверлея.

Во всех списках строк переменных разделителями записей могут служить \[ \\t\\r\\n\]. Если вы хотите использовать один из них внутри строки, не забудьте экранировать его с помощью **\\**. Все обратные слэши также должны быть экранированы, поскольку служебные обратные слэши при символах обратного слэша и при разделителях удаляются. Если вы хотите использовать переменную в "обычном" виде, вы можете прибегнуть к отложенной замене: конструкция **%{\\**_ПЕРЕМЕННАЯ_**}** вставит в текст значение _ПЕРЕМЕННОЙ_ с экранированными \[\\ \\t\\r\\n\]. (Подробнее см. в разделе об отложенной замене.)

**EAPI\_REGEX**

Это регулярное выражение соответствует распознанным EAPI в суффиксах ебилдов, интерпретируемых согласно GLEP 55\. Может потребоваться изменить это выражение локально, в зависимости от установленной версии portage (чтобы убедиться, что она умеет производить синтаксический анализ соответствующих EAPI). В исключительных случаях переменная может оказаться пуста; тогда все ебилды с EAPI-суффиксами будут проигнорированы.

**SAVE\_WORLD** **(true**/**false)**

Если эта переменная имеет значение true, данные вашего world-файла будут храниться в /var/cache/eix. Таким образом, всякий, кто имеет доступ к этому файлу, будет располагать содержимым вашего "мира". Если вы этого не хотите, не ставьте значением переменной true.

**CURRENT\_WORLD** **(true**/**false)**

При значении false будут использованы данные world-файла, хранящиеся в файле /var/cache/eix, даже если текущий world сам доступен для чтения. Иначе эти данные будут переопределены текущим world-файлом (при условии, что он доступен для чтения).

**SKIP\_PERMISSION\_TESTS** **(true**/**false)**

При значении **true** eix-update не будет проверять группы и привилегии. Вероятно, это имеет смысл, если вы используете более тонкий способ настройки прав доступа (NSS/LDAP, acl, утилиты, использующие pam и т.д.), иначе eix может неверно определить права. Единственный недостаток такого режима заключается в том, что eix-update не будет выдавать ошибок в начале, а выдаст ошибку (иногда неверно ее истолковав) при попытке получить доступ к кэш-файлу без достаточных привилегий.

**EBUILD\_USER**, **EBUILD\_GROUP**, **EBUILD\_UID**, **EBUILD\_GID**

Эти переменные определяют права методов кэширования **ebuild**/**ebuild\***. Подробнее см. в разделе о данных методах кэширования.

**PORTAGE\_ROOTPATH**, **PORTAGE\_BIN\_PATH**

Если эти переменные не пусты, они без изменений передаются сценарию ebuild.sh, при кэшировании методом **ebuild\***. Заметьте, что ebuild.sh использует данные переменные для расчета пути PATH, так что здесь кроется серьезная угроза безопасности.

**NOFOUND\_STATUS** **(целое число)**

Это значение используется в качестве статуса выхода в том случае, если найдено 0 соответствий запросу. Учитывается значение переменной **COUNT\_ONLY\_PRINTED**.

**MOREFOUND\_STATUS** **(целое число)**

Это значение используется в качестве статуса выхода в том случае, если найдено хотя бы 2 соответствия запросу. Учитывается значение переменной **COUNT\_ONLY\_PRINTED**.

**QUICKMODE** **(true**/**false)**

Если переменная имеет значение true, eix и eix-diff по умолчанию будут использовать опцию **--quick**.

**CAREMODE** **(true**/**false)**

Если переменная имеет значение true, eix и eix-diff по умолчанию будут использовать опцию **--care**.

**USE\_BUILD\_TIME** **(true**/**false)**

Переменная определяет, использовать ли запись BUILD\_TIME из базы данных портежей (если она существует) вместо отметки времени каталога (обычно это время установки). Разница между двумя этими возможностями имеет значение только для пакетов, устанавливаемых из .tbz2-архивов. В большинстве случаев важнее время сборки; эти данные к тому же надежнее. К сожалению, время сборки доступно только для пакетов, собранных и установленных portage не ниже версии 2.2\_rc63\. Чтобы выяснить, к каким пакетам это относится, а к каким нет, можно использовать команду **eix-installed \[no-\]buildtime**. Считывание времени сборки всегда занимает больше времени, чем использование отметки времени из каталога (даже если время сборки недоступно). Поэтому, возможно, будет удобнее назначить данной переменной значение **false**, если для вас важнее скорость работы eix, чем корректность данных времени сборки.

**QUIETMODE** **(true**/**false)**

Если переменная имеет значение true, eix и eix-diff по умолчанию будут использовать опцию **--quiet**.

**PRINT\_APPEND** **(строка)**

Эта строка добавляется к выводу опции of --print. Внутри нее стандартно интерпретируются специальные символы, например, \\n. По умолчанию - новая строка для разумного вывода в интерактивной оболочке. Обратите внимание, что при замене команд в сценариях оболочки удаляются все пробелы в конце, поэтому новая строка не создаст здесь никакого неудобства (а пробелы в конце переменной в сценарии в любом случае будут удалены). Поэтому чтобы считывать переменные, предоставляемые eix, внутри сценария оболочки без опущения завершающих пробелов, следует использовать видимый символ для переменной PRINT\_APPEND и работать с конструкциями типа \*<nt\>ПЕРЕМЕННАЯ="\`PRINT\_APPEND=x eix --print ПЕРЕМЕННАЯ\`" ; ПЕРЕМЕННАЯ="${VAR%x}"</nt\>\* 
\*NEWLINE\* \*(true\*<nt\>/</nt\>\*false)\* 
p((((. Если переменная имеет значение true, eix будет переходить на новую строку после каждой версии, для которой строка формата предусматривает какой-либо вывод. Значение \*true\* может быть полезно, если вы используете пустые строки формата, выводящие только одну строку (если не хотите вручную добавлять переход на новую строку в строке формата). Однако если вы используете строку формата, которая выводит по версии на строку, причем отображаются только те версии, которые удовлетворяют определенному запросу, оказывается довольно неудобно отслеживать непосредственно в строке формата, делать ли явный переход на новую строку или это произойдет автоматически. В этом случае оптимальным решением будет значение \*NEWLINE=false\*<nt\>.</nt\> Стандартная строка формата eix корректно обрабатывает оба варианта (проверяет значение переменной \*NEWLINE\* и переходит на новую строку, только если это требуется).
p((((. Если только вам не нужна поддержка строки формата, которую вы прописали ранее, мы рекомендуем сохранить значение по умолчанию \*NEWLINE=false\* и вручную добавить \*\\n\* (или явно перейти на новую строку) в конце строки формата. Если же вы самостоятельно писали строки формата, следует обновить их так, чтобы происходил переход на новую строку, а не указывать \*NEWLINE=true\*. Данная возможность существует лишь в интересах обратной совместимости и может быть исключена в следующих версиях eix. 
\*DEFAULT\_FORMAT\* \*(normal\*<nt\>/</nt\>\*compact\*<nt\>/</nt\>\*verbose)\* 
p((((. Определяет, какой из двух режимов - \*<nt\>--compact</nt\>\* или \*<nt\>--verbose</nt\>\* - используется по умолчанию.
\*DIFF\_ONLY\_INSTALLED\* \*(true\*<nt\>/</nt\>\*false)\* 
p((((. Если переменная имеет значение true, eix-diff будет обрабатывать изменения версии только для установленных пакетов.
\*DIFF\_NO\_SLOTS\* \*(true\*<nt\>/</nt\>\*false)\* 
p((((. Если переменная имеет значение true, eix-diff не будет обрабатывать слоты для изменившихся версий.
\*DIFF\_SEPARATE\_DELETED\* \*(true\*<nt\>/</nt\>\*false)\* 
p((((. Если переменная имеет значение true, eix-diff отобразит удаленные пакеты в отдельном блоке. Иначе eix-diff выведет удаленные и измененные пакеты общим алфавитным списком.
\*DIFF\_PRINT\_HEADER\* \*(true\*<nt\>/</nt\>\*false)\* 
p((((. Если переменная имеет значение true, eix-diff выведет информационный заголовок.
\*NO\_RESTRICTIONS\* \*(true\*<nt\>/</nt\>\*false)\* 
p((((. Если переменная имеет значение false, будут выведены данные RESTRICTION и PROPERTIES. 
\*RESTRICT\_INSTALLED\* \*(true\*<nt\>/</nt\>\*false)\* 
p((((. Если переменная имеет значение true, будут рассчитываться ограничения загрузки и зеркала для установленных версий.
\*CARE\_RESTRICT\_INSTALLED\* \*(true\*<nt\>/</nt\>\*false)\* 
p((((. Если переменная имеет значение true, ограничения загрузки и зеркала для установленных версий всегда будут браться с диска, даже если эти данные могут быть считаны непосредственно с соответствующей версии пакета. Это медленнее, но надежнее, так как будут выявлены и измененные ограничения.
\*FORMAT\*, \*FORMAT\_COMPACT\*, \*FORMAT\_VERBOSE\* \*(строка)\* 
p((((. Эти переменные определяют соответственно стандартный, компактный и подробный форматы вывода \*eix\*<nt\>.</nt\> См. \*FORMATSTRING\*<nt\>.</nt\> Начиная с eix-0.13.4 эти переменные просто расширяются на отложенную замену переменных \*FORMAT\_ALL\*, \*FORMAT\_ALL\_COMPACT\* и \*FORMAT\_ALL\_VERBOSE\*<nt\>, соответственно</nt\>. Такое определение призвано упростить доступ к стандартному определению, когда вы меняете определение \*FORMAT\*<nt\>.</nt\> 
\*DIFF\_FORMAT\_NEW\*, \*DIFF\_FORMAT\_DELETE\*, \*DIFF\_FORMAT\_CHANGED\* \*(строка)\* 
p((((. Эти переменные определяют формат вывода для пакетов, которые были добавлены, удалены или для которых стала доступна новая стабильная версия. Они используются только \*eix-diff\*<nt\>.</nt\> См. \*FORMATSTRING\*<nt\>.</nt\> Начиная с eix-0.13.4 эти переменные просто расширяются на отложенную замену переменных \*DIFF\_FORMAT\_ALL\_NEW\*, \*DIFF\_FORMAT\_ALL\_DELETE\* и **DIFF\_FORMAT\_ALL\_CHANGED**, соответственно.

**FORMAT\_INSTALLATION\_DATE**, **FORMAT\_SHORT\_INSTALLATION\_DATE**

Определяется формат функции strftime(), используемые для отображения времени установки (в стандартном или, соответственно, сокращенном виде).

**FORMAT\_INSTALLED\_USE**

Определяет printf-подобный формат, используемый для отображения USE-флагов установленных пакетов. Если значением переменной является пустая строка, обработка происходит несколько быстрее, поскольку данные не будут считываться.

**FORMAT\_BEFORE\_KEYWORDS**, **FORMAT\_AFTER\_KEYWORDS**, **FORMAT\_BEFORE\_EFFECTIVE\_KEYWORDS**, **FORMAT\_AFTER\_EFFECTIVE\_KEYWORDS**

Эти строки выводятся перед/после строки KEYWORDS (текущей) для данной версии.

**FORMAT\_BEFORE\_SET\_USE**, **FORMAT\_AFTER\_SET\_USE**, **FORMAT\_BEFORE\_UNSET\_USE**, **FORMAT\_AFTER\_UNSET\_USE**

Эти строки выводятся перед/после включенных/отключенных USE-флагов установленных версий.

**FORCE\_USECOLORS** **(true**/**false)**

Отображать в цвете, даже если стандартный вывод не терминал.

**FORCE\_PERCENTAGE** **(true**/**false)**

Отображать ход выполнения операции в процентах, даже если стандартный вывод не терминал.

**STYLE\_VERSION\_SORTED** **(true**/**false)**

Определяет, включена ли по умолчанию опция **--versionsort**.

**STYLE\_VERSION\_LINES** **(true**/**false)**

Определяет, включена ли по умолчанию опция **--versionlines**.

**DUP\_PACKAGES\_ONLY\_OVERLAYS** **(true**/**false)**

Определяет, производится ли проверка дублирующих друг друга пакетов только среди оверлеев, т.е. будет ли считаться пакет дублированным только в том случае, если он существует по меньшей мере в двух оверлеях.

**DUP\_VERSIONS\_ONLY\_OVERLAYS** **(true**/**false)**

Определяет, производится ли проверка дублирующих друг друга версий только среди оверлеев, т.е. будет ли считаться пакет дублированным только в том случае, если он существует по меньшей мере в двух оверлеях.

**DEFAULT\_IS\_OR** **(true**/**false)**

Если имеется несколько шаблонов в аргументах, не соединенных логически (операторами -a и -o), eix подразумевает их неявное объединение. Если значением этой переменной является true, подразумевается, что производится дизъюнкция -o (or), иначе конъюнкция -a (and).

**OVERLAYS\_LIST** **(all**/**all-if-used**/**all-used**/**all-used-renumbered**/**no)**

Пользователи, работающие со множеством оверлеев, хотели ли бы, чтобы в конце отображались не все оверлеи, а только действительно используемые. Это поведение настраивается здесь. Значение переменной интерпретируется следующим образом:

**all-if-used**/**if-used**/**if**

Отображать все оверлеи, если используется хотя бы один из них. В версиях eix ниже 0.6.0 эта настройка предлагалась по умолчанию.

**used-renumbered**/**renumber**/**renumbered**/**number**

Отображать только действительно используемые оверлеи с "правильной" нумерацией (т.е. если используется только два оверлея, они будут пронумерованы как \[1\] и \[2\]). Этот подход неудобен тем, что нумерация оверлеев меняется в зависимости от запроса. Впрочем, порядок следования остается прежним.

**all-used**/**only-used**/**used**

Отображать только действительно используемые оверлеи, сохраняя единую, не зависящую от запроса нумерацию (в одной базе данных).

**no**/**false**

Никогда не выводить перечень оверлеев.

иное

Выводить перечень оверлеев при каждом запросе (даже если ни один из них не нужен).

**LEVENSHTEIN\_DISTANCE** **(целое число)**

Устанавливает расстояние Левенштейна по умолчанию.

**EXCLUDE\_OVERLAY** **(список строк)**

Устанавливает перечень подстановочных шаблонов для путей к оверлеям, исключенным из индекса. См. опцию **--exclude-overlay** для \*eix-update\*.

**ADD\_OVERLAY** **(список строк)**

Устанавливает перечень оверлеев, добавленных в индекс. См. опцию **--add-overlay** для \*eix-update\*.

**EXPORT\_PORTDIR\_OVERLAY** **(true**/**false)**

Если значение переменной true, и все оверлеи исключены/добавлены, будет экспортирована соответственно измененная переменная \*PORTDIR\_OVERLAY\*. Это означает, что в некотором смысле и соответствующие еклассы этих оверлеев <nt\>исключены/добавлены для методов кэширования eix и eix\*.</nt\> 
\*CACHE\_METHOD\_PARSE\* \*(строка)\* 
p((((. <nt\>Эта строка добавляется ко всем методам кэширования, использующим parse/parse\*/ebuild/ebuild\*.</nt\> По умолчанию содержит строку \*\#metadata-flat\*<nt\>.</nt\> Если только вы не экспериментируете с настройками, вам, скорее всего, потребуется именно этот метод. Он подразумевает, что если для ебилда доступны текущие метаданные, они будут использованы, вместо парсинга/исполнения ебилда. Последние либо не вполне надежны (парсинг) либо занимают долго времени (исполнение), поэтому обращение к метаданным, при условии, что они доступны и обновлены, всегда предпочтительнее.
\*PORTDIR\_CACHE\_METHOD\*, \*OVERLAY\_CACHE\_METHOD\* \*(строка)\* 
p((((. Устанавливает тип кэша, используемого портежами и оверлеями. По умолчанию переменная \*PORTDIR\_CACHE\_METHOD\* имеет значение \_metadata-flat\_<nt\>,</nt\> \*OVERLAY\_CACHE\_METHOD\* - \_<nt\>parse|ebuild\*</nt\>\_<nt\>.</nt\> 
p((((. \*Внимание:\* Если вы не вполне доверяете ебилдам в используемых вами оверлеях, лучше указать значение \*OVERLAY\_CACHE\_METHOD=parse\*<nt\>.</nt\> 
p((((. Возможно, вы захотите временно выставить значение \*<nt\>OVERLAY\_CACHE\_METHOD=eix\*::~</nt\>\*<nt\> -</nt\> как будет разъяснено ниже, в этом случае eix по умолчанию будет брать данные об оверлеях из прежней базы данных eix. 
p((((. Ниже описаны доступные методы кэширования. Возможно, вы захотите переопределить метод кэширования для отдельных оверлеев. Это можно сделать с помощью следующих переменных:
\*CACHE\_METHOD\*, \*OVERRIDE\_CACHE\_METHOD\* \*(список строк)\* 
p((((. Эти переменные представляют собой списки строк вида "\_оверлей\_ \_метод\_ \_оверлей\_ \_метод\_ ...". Методом кэширования \_оверлея\_ устанавливается следующий за ним \_метод\_<nt\>;</nt\> тем самым переопределяются значения по умолчанию переменной \*OVERLAY\_CACHE\_METHOD\* (или \*PORTDIR\_CACHE\_METHOD\* если \_оверлей\_ - каталог \*PORTDIR\*). \_оверлей\_ интерпретируется как подстановочный шаблон, который должен соответствовать \_пути\_ к оверлею (разрешаются символические ссылки) <nt\>(вы не можете указать здесь имя репозитария, вы должны использовать настоящий </nt\>\_путь\_). Новые записи переопределяют старые: последняя удовлетворяющая запись имеет приоритет. 
p((((. Переменные \*CACHE\_METHOD\* и \*OVERRIDE\_CACHE\_METHOD\* отличают тем, что первая применяется незамедлительно, тогда как вторая может быть использована для расширения/переопределения неявных изменений при использовании \*KEEP\_VIRTUALS\* (см. ниже). 
p((((. Определения переменных \*CACHE\_METHOD\* и \*OVERRIDE\_CACHE\_METHOD\* по умолчанию содержат \*<nt\>%{ADD\_CACHE\_METHOD}</nt\>\* и, соответственно, \*<nt\>%{ADD\_OVERRIDE\_CACHE\_METHOD}</nt\>\*. Согласно механизму отложенной замены (сущность которого мы раскрываем в другом разделе), это означает, что переменные \*ADD\_CACHE\_METHOD\* и **ADD\_OVERRIDE\_CACHE\_METHOD** также могут быть использованы для локального переопределения метода кэширования. Если вы изменяете **CACHE\_METHOD** или **OVERRIDE\_CACHE\_METHOD** в файле **/etc/eixrc**, рекомендуется добавить " **%{ADD\_CACHE\_METHOD}**" или, соответственно, " **%{ADD\_OVERRIDE\_CACHE\_METHOD}**" (обратите внимание на пробел перед **%**) в конце измененных определений, чтобы эти переменные продолжали применяться для локального переопределения значений.

Доступны следующие методы кэширования:

**metadata-flat** или **metadata-flat:**_ПУТЬ_

Использовать кэш метаданных, расположенный в дереве портежей ($PORTDIR/metadata/cache). Это стандартный метод, который работает всегда, когда дерево портежей доступно для чтения при запуске eix-update.

Если вы явно пропишете _ПУТЬ_, это значение переопределит путь, указанный выше. При этом вы должны использовать полный путь (без префикса). Возможно, вы захотите переопределить _ПУТЬ_, если вы используете какой-либо пакетный менеджер для генерирования метаданных в соответствующем каталоге.

**metadata-assign** или **metadata-assign:**_ПУТЬ_

Аналогично **metadata-flat** с той разницей, что файлы внутри кэша метаданных ожидаются в "формате присвоения" (ТИП=значение). Это справедливо для ряда оверлеев alt-gentoo.

**sqlite**

Это чрезвычайно быстрый метод кэширования; для его использования необходимо, что portage работал с бэкендом sqlite. См. _[http://en.gentoo-wiki.com/wiki/Portage\_SQLite\_Cache](http://en.gentoo-wiki.com/wiki/Portage_SQLite_Cache)_ (первоначальная версия этого руководства располагалась на странице _[http://gentoo-wiki.com/TIP\_speed\_up\_portage\_with\_sqlite](http://gentoo-wiki.com/TIP_speed_up_portage_with_sqlite)_ , которая, возможно, всё еще доступна по адресу _[http://gentoo-wiki.info/TIP\_speed\_up\_portage\_with\_sqlite](http://gentoo-wiki.info/TIP_speed_up_portage_with_sqlite)_). Обратите внимание, что, в отличие от метода кэширования **metadata**, принимаемого по умолчанию, при использовании данного метода перед вызовом **eix-update** вы должны будете выполнить **emerge --metadata**.

Поскольку этот метод поддерживается, только если установлен пакет **sqlite**, он может не поддерживаться "из коробки". Если вы планируете его использовать, вам потребуется установить **eix** с соответствующим USE-флагом (или, при ручной установке, выполнить _./configure --with-sqlite_ перед компиляцией).

Что касается остальных методов кэширования, они обрабатывают только категории, подключенные через profile/categories (в дереве портежей или оверлее). Если вам это не подходит, используйте **sqlite\*** (см. ниже).

**sqlite\***

Аналогичен методу кэширования **eix** с той разницей, что в кэш добавляются все категории, найденные в _ФАЙЛе_, даже те, которые не были подключены через profile/categories.

**cdb**

Используйте этот метод кэширования, если у вас portage версии ниже 2.1 и модуль cdb из _[http://forums.gentoo.org/viewtopic-t-261580.html](http://forums.gentoo.org/viewtopic-t-261580.html)_ в качестве бэкенда для portage (cdb со словарями cpickle'd в качестве значений). Заметьте, что, в отличие от стандартного **metadata-\***, при использовании данного метода перед вызовом **eix-update** вы должны будете выполнить **emerge --metadata** .

**flat** или **flat:**_ПУТЬ_

Этот метод аналогичен **metadata-flat** с той разницей, что метаданные ожидаются в каталоге _ПУТЬ_ - ${PORTAGE\_OR\_OVERLAY\_DIR}_. Если \_ПУТЬ_ опущен, его значением по умолчанию принимается **/var/cache/edb/dep**.

Вы можете использовать этот метод кэширования с portage версий ниже 2.1 и бэкендом по умолчанию.

**assign** или **assign:**_ПУТЬ_

Этот метод аналогичен **flat** с той разницей, что файлы внутри кэша метаданных ожидаются в "формате присвоения" (ТИП=значение). Это справедливо для portage-2.1 с дефолтным бэкендом.

Если вы используете portage-2.1 и выше с бэкендом по умолчанию, вы можете использовать этот метод, если у вас нет доступа к дереву портежей при выполнении eix-update. Заметьте, что, в отличие от стандартного **metadata-\***, при использовании данного метода перед вызовом **eix-update** вы должны будете выполнить **emerge --metadata** . В таком случае, вы скорее всего обратитесь к соответствующей опции eix-sync.

**repo-flat** или **repo-flat:**_ПУТЬ_ / **repo-assign** или **repo-assign:**_ПУТЬ_

Метод аналогичен **flat**/**assign** с той разницей, что метаданные ожидаются в каталоге _ПУТЬ_**/**_${repo\_name}_. Если значение _${repo\_name}_ пусто, за имя репозитария принимается **x-**_XXX_, где _XXX_ - последний ненулевой компонент пути к каталогу портежей/оверлея. Это поведение соответствует политике именования paludis. Если в результате предлагается ошибочный путь к оверлею, вы можете переопределить его вручную, например, так: **OVERRIDE\_CACHE\_METHOD='**_ошибочный\_путь_****_metadata-assign_**:**_исправленный\_путь\_к\_оверлею_**'**_._

**parse**\[**\#**\_метод\_для\_метаданных**\]...**

Извлечь информацию из ебилдов, проанализировав их эвристически. Использование данного метода хотя и не ставит под угрозу безопасность, но может стать причиной ряда проблем. Например, если переменные получают значения только в еклассах, они будут проигнорированы. Среди проблем, с которыми сопряжено применение данного метода, можно указать отсутствующие данные SLOT для типичных ебилдов категории kde-base или фиксированных номеров версий для кросс-компиляторов gcc. Соответствует методу кэширования **none** в старых версиях eix (ниже 0.11.1).

Возможно добавить одну или более строк вида **\#**_метод\_для\_метаданных_, где под _методом\_для\_метаданных_ подразумевается один из перечисленных выше методов кэширования (исключая **sqlite** и **cdb**). В этом случае методы кэширования метаданных используются для проверки, содержат ли эти метаданные они более новую информацию по сравнению с ебилдом. Если это так, то вместо данных ебилда будут использоваться эти метаданные (приоритет имеют первые удовлетворяющие запросу метаданные).

Как правило, пользователю нужно именно такое поведение, особенно когда речь идет об оверлеях, поскольку метаданные надежнее, чем результаты, полученные методом кэширования **parse**. Разумеется, это имеет смысл лишь в том случае, если метаданные нашего оверлея _foo_ регулярно обновляются мейнтейнерами оверлея.

**egencache --repo=**_foo_ --update

(Будет ли выполнено это действие для оверлеев layman, зависит от команды сопровождения оверлея; для своих локальных оверлеев вы, естественно, можете вручную ввести приведенную команду.

Как правило, это поведение удовлетворяет большинство пользователей, поэтому строка в **CACHE\_METHOD\_PARSE** по умолчанию добавляется к методу кэширования **parse**.

Конечно, если вы заранее знаете, что метаданные оверлея свежие, будет (несколько) быстрее напрямую использовать подходящий метод кэширования (как правило, **metadata-flat**). Это имеет смысл, когда, например, вызывается **egencache** из сценария синхронизации оверлея (e.g. in eix-sync).

**parse\***\[**\#**метод-для\_метаданных\]...

Этот метод кэширования наалогичен **parse** с той разницей, что переменные не расширяются в определениях переменных. Он соответствует методу кэширования **none\*** из предыдущих (ниже 0.11.1) и ранних версий eix (before 0.7.1)

**ebuild**\[**\#**метод\_для\_метаданных\]...

Если кэш портежей недоступен (например, речь идет об оверлеях), этот метод кэширования обеспечивет наибольшую совместимость, но и наиболее медленный. Данные извлекаются из ебилда с помощью "/usr/bin/ebuild ... depend". Поскольку все ебилды будут выполняться в оболочке bash, это может быть небезопасно, если вы не уверены в надежности всех ebuild-сценариев и переменных окружения. **eix-update** предпримет попытку заменить пользователя/группу на **EBUILD\_USER**/**EBUILD\_GROUP** (если предыдущая переменная не имеет смысла - используя **EBUILD\_UID**/**EBUILD\_GID**), прежде чем выполнять ебилд. Окружение преднамеренно не инициализируется до фактического начала выполнения действия, чтобы можно было последовательно передать несколько переменных ебилду. Однако это же может привести к неожиданному поведению или даже к угрозе безопасности, поскольку многие сценарии bash могут быть обойдены в разных окружениях. Во избежание проблем используйте **env -i eix-update**, если для вас важен этот аспект.

**Используйте этот метод, только если вы уверены в надежности всех ебилдов, к которым он будет применен!**

Об опциональных дополнениях **\#**_метода\_для\_метаданных_ см. в описании метода кэширования **parse**. Заметьте, что, если доступны соответствующие метаданные, в общем случае этот вариант окажется быстрее, чем выполнение ебилда.

**ebuild\***\[**\#**метод\_для\_метаданных\]...

Этот метод представляет собой несколько более быструю, хотя и в меньшей степени совместимую версию **ebuild**: данные берутся недокументированного "/usr/lib/portage/ebuild.sh". Вместо выполнения программы на для каждого ебилда, как это происходит при использовании метода кэширования **ebuild**, "only" a lengthy shell-script and the ebuild itself is executed (таким образом, этот метод небезопасен, если вы не вполне уверены в надежности всех ebuild-сценариев). Большинство переменных окружения, за исключением переменных portage и PATH, инициализируются; PORTAGE\_BIN\_PATH и PORTAGE\_ROOTPATH экспортируются (учтите, что ebuild.sh использует эти переменные для вычисления PATH, создавая тем самым серьезную угрозу безопасности); некоторые специфичные для ебилдов переменные, такие как $P, получают свои значения при выполнении ебилда. Этот метод обеспечивает несколько худшую совместимость, нежели **ebuild**, и успешность его применения в большей степени зависит от версии portage. Тем не менее он работает значительно быстрее, чем **ebuild**, и достаточно стабилен для обработки, например, типичных ебилдов категории kde-base.

**Используйте этот метод, только если вы уверены в надежности всех ебилдов, к которым он будет применен!**

**parse|ebuild**, **parse\*|ebuild**, **parse|ebuild\***, **parse\*|ebuild\*** \[**\#**метод\_для\_метаданных\]...

Здесь скомбинированы методы кэширования **parse**/**parse\*** и **ebuild**/**ebuild\***. Сначала каждый ебилд проверяется на возможность использования метода **parse**/**parse\***. Если предполагаемый результат содержит лакуны или выглядит станно, ебилд проверяется на возможность использования метода **ebuild**/**ebuild\***. По эмпирическим данным этот метод работает значительно быстрее, чем **ebuild**/**ebuild\***, но всё же намного медленнее, чем **parse**/**parse\***. Конечно, он имеет те же риски безопасности, что и **ebuild**/**ebuild\***.

**Используйте этот метод, только если вы уверены в надежности всех ебилдов, к которым он будет применен!**

**eix** или **eix:**_ФАЙЛ_ или **eix:**_ФАЙЛ_:_оверлей_

Использовать кэш-файл _ФАЙЛ_, предварительно сгенерированный **eix-update**. Если значение опущено или пусто, по умолчанию _ФАЙЛ_ - это /var/cache/eix.

Что касается остальных методов кэширования, для них будут считываться только категории, подключенные через profile/category (в дереве портежей или оверлее). Если вам это не нужно, используйте **eix\*** (см. ниже).

Если _оверлей_ не задан или имеет пустое значение, будет обрабатываться только основное дерево портежей в _ФАЙЛе_, а оверлеи из _ФАЙЛа_ игнорируются. Иначе будет считываться только та часть _ФАЙЛа_, которая соответствует _оверлею_. Под соответствием мы здесь подразумеваем, что будет использован первый оверлей из _ФАЙЛа_, удовлетворяющий подстановочному шаблону. При проверке, удовлетворяет ли оверлей шаблону, сначала сканируется метка, затем путь и, наконец, номер оверлея в _ФАЙЛе_. Заметьте, что _оверлей_ обычно не зависит от действительных имен оверлеев или их порядка - роль играют только имена/порядок, сохраненные в _ФАЙЛе_.

Существуют два исключения для _оверлея_, обрабатываемые согласно другим правилам:

Если _оверлей_ имеет специальное значение "~", в качества аргумента \_оверлей\_ будет неявно использована действительная метка этого оверлея; если действительная метка оверлея пуста или не подходит, используется текущий путь к оверлею.

Если _оверлей_ имеет специальное значение "\*", будут обработаны **все** оверлеи в _ФАЙЛЕ_. Для большинства пользователей это предпочтительное поведение, поскольку в результате, если _ФАЙЛ_ изначально содержал несколько оверлеев, структура оверлеев будет "выровнена".

**eix\*** или **eix\*:**_ФАЙЛ_ или **eix\*:**_ФАЙЛ_:_оверлей_

Аналогичен методу кэширования **eix** с той разницей, что добавляются все категории, найденные в _ФАЙЛе_, даже те, которые были включены через profile/categories.

Данный метод кэширования имеет смысл, если _ФАЙЛ_ содержит данные какого-либо каталога оверлея, для которого неизвестны или, возможно, устарели соответствующие файлы profile/categories на локальном хосте.

Применяется для **eix-remote**.

Обратите внимание, что, в частности, при использовании **PORTDIR\_CACHE\_METHOD="eix\*::~"**, данные оверлея по умолчанию лишь "копируются" из предыдущего кэш-файла eix.

**KEEP\_VIRTUALS** **(true**/**false)**

Если переменная имеет значение true, eix-update сохранит все виртуальные оверлеи из предыдущей базы данных, если таковые имеются. Тот же результат вы получили бы,добавив для каждого виртуального оверлея из старой базы "_имя-оверлея_" в переменной **ADD\_OVERLAY** и соответствующую запись "_оверлей_ eix\*::_оверлей_" в переменной **CACHE\_METHOD**. Это означает, что данная опция должна переопределять настройки **CACHE\_METHOD**, но может быть сама переопределена значением **OVERRIDE\_CACHE\_METHOD**.

**REPO\_NAMES**

Эта переменная содержит список строк вида "_шаблон-каталога_ _метка-оверлея_ _шаблон-каталога_ _метка оверлея_ ...". При создании нового файла кэша оверлей, совпадающий с _шаблоном-каталога_, получает _метку-оверлея_, независимо от содержимого файла profiles/repo\_name. Эта переменная может также сопоставлять метки виртуальным оверлеям, которые не содержат такого файла. Кроме того, переменная также переопределяет метки оверлеев, установленные переменной KEEP\_VIRTUALS. Старые записи переопределяются новыми: приоритет имеет последнее соответствие.

**LOCAL\_PORTAGE\_CONFIG** **(true**/**false)**

Если переменная имеет значение false, содержимое /etc/portage и **ACCEPT\_KEYWORDS** (будь то в файле make.conf или в окружении) игнорируется. В eix начиная с версии 0.7.9 рекомендуется оставлять за этой переменной значение true, поскольку при значении false часть информации будет упущена.

**ALWAYS\_ACCEPT\_KEYWORDS** **(true**/**false)**

Если переменная имеет значение true, переменная **ACCEPT\_KEYWORDS** будет использована даже без **LOCAL\_PORTAGE\_CONFIG**, например, для определения стабильности "по умолчанию".

**UPGRADE\_LOCAL\_MODE** **(+** или **local**/**-** или **non-local**/иное**)**

Есле переменная имеет значение **+** / **-**, вызов eix с опцией **--upgrade** всегда будет производить поиск так, как если бы переменная **LOCAL\_PORTAGE\_CONFIG** имела значение **true** / **false**.

**RECOMMEND\_LOCAL\_MODE** **(+** или **local**/**-** или **non-local**/иное**)**

Если переменная имеет значение **+** / **-**, рекомендации по обновлению/откату, равно как и проверка изменений версий, производимая eix-diff, всегда будут отрабатывать, как если бы переменная **LOCAL\_PORTAGE\_CONFIG** имела значение **true** / **false**.

**UPGRADE\_TO\_HIGHEST\_SLOT** **(true**/**false)**

Если переменная имеет значение true, любая проверка предложит на обновление установленный пакет не с лучшей стабильной версией в слоте. Исключения из этого общего правила можно прописать в **/etc/portage/package.slot\_upgrade\_forbid** или, соответственно, **/etc/portage/package.slot\_upgrade\_allow**.

**RECURSIVE\_SETS** **(true**/**false)**

Если переменная имеет значение true, сеты и пакеты в составе включенного сета рассматриваются как часть сета более высокого уровня.

**PRINT\_EFFECTIVE\_KEYWORDS** **(true**/**false)**

Если переменная **PRINT\_KEYWORDS** используется и ее значение равно true, причем ключевое слово KEYWORD версии изменено профилем, то на основе значения KEYWORDS, установленного в ебилде, будут отображены действующие ключевые слова (определяются профилем).

**XML\_KEYWORDS**(full**/**effective**/**both**/**true**/**full\***/**effective\***/**none**/**false)

При использовании опции --xml данная переменная решает, отображать ли для каждой версии полные/действительные ключевые слова **KEYWORDS** (или оба типа). Под "полным" (full) ключевым словом здесь подразумевается строка **KEYWORDS** в ебилде, а под "действительным" (effective) - ключевое слово, трансформированное профилем. Значения **full\***/**effective\*** аналогичны **full**/**effective**, но для обоих типов ключевых слов вывод будет произведен только в том случае, если их значения различаются. Значения **true**/**false** эквивалентны **full\***/**none**.

**XML\_OVERLAY** **(true**/**false)**

При использовании опции --xml эта переменная определяет, будет ли для каждой версии отображаться оверлей (т.е. путь к нему). Эта настройка не повлияет на версии из оверлеев без метки (имени репозитария): для таких версий вывод во всех случаях подразумевает отображение пути доступа к оверлею.

**SORT\_INST\_USE\_ALPHA** **(true**/**false)**

Если переменная имеет значение **true**, USE-флаги установленных пакетов будут выведены в алфавитном порядке. Иначе первыми отображаются (в алфавитном порядке) те флаги, статус которых был изменен при установке пакета, а затем (также в алфавитном порядке) все остальные флаги.

**CHECK\_INSTALLED\_OVERLAYS** **(true**/**false**/**repository)**

Если переменная имеет значение **true**, утилита всегда будет проверять, из какого оверлея установленный пакет. Если ее значение **false**, будут проверены только пакеты с версиями, доступными как минимум в двух деревьях - иными словами, только те пакеты, которые, судя по базе данных, могли быть установлены из другого оверлея. Однако это может быть и не так, если такой пакет был удален из какого-либо оверлея или если сам оверлей теперь отсутствует в базе данных.

Вы можете использовать специальное, компромиссное значение **repository**: если при установке были сохранены данные о репозитарии (в последних версиях portage это именно так; чтобы проверить, как ведет себя ваша версия portage, выполните **eix-installed \[no-\]repository**), то во всех случаях будут использоваться эти данные. Только если данные нечитаемы или не соответствуют состоянию системы, поведение утилиты для данной версии будет таким же, как при **CHECK\_INSTALLED\_OVERLAYS=false**.

Если вы выставите значением этой переменной **false** или **repository**, особенно в сочетании с опциями -T (если значение **NONEXISTENT\_IF\_OTHER\_OVERLAY** равно true) и -J, то получите огромный прирост скорости. Но вы должны отдавать себе отчет в том, что используемые в этом случае сведения об установленном оверлее не вполне надежны (для версий, установленных с ранними версиями portage). В частности, опция -T не обнаружит, что установленная версия пакета происходит из дублированного оверлея, если в текущей базе данных все версии пакета из одного (другого) дерева.

**OBSOLETE\_MINUSASTERISK** **(true**/**false)**

Если переменная имеет значение true, обрабатывать **-\*** в /etc/portage/package.keywords так, как это делал portage версии 2.1.2 и ниже. Уже в portage-2.1.2 ключевое слово **-\*** фактически устарело и было заменено на **\*\***, которому может соответствовать всё что угодно (даже ебилд с пустым значением **KEYWORDS**). Заметьте, что существуют родственные ключевые слова **\*** и **~\***, которые разрешают установку стабильных или, соответственно, нестабильных версий любой архитектуры, указанной в **KEYWORDS**.

**PRINT\_COUNT\_ALWAYS** **(true**/**false**/**never)**

Если переменная имеет значение true, в последней строке всегда будет отображаться количество совпадений с запросом, даже если их 0 или 1\. Если **PRINT\_COUNT\_ALWAYS=never**, то последняя строка в любом случае будет опущена. В обычных условиях неудобен и тот, и другой вариант, однако они могут упростить написание отдельных сценариев, основанных на парсинге вывода eix.

**COUNT\_ONLY\_PRINTED** **(true**/**false)**

Если переменная имеет значение false, будет выведено только количество соответствий запросу, независимо от того, насколько они результативны в действительности. Это может быть полезно для ускорения отдельных сценариев, для которых вам важно только число соответствий, если вы используете, например, **FORMAT=''**.

**DEFAULT\_MATCH\_FIELD** **(список строк)**

Это список строк вида _регулярное\_соответствие_\[\\n\\r\\t \]_поле\_соответствия_, который используется для определения стандартного поля соответствия. Шаблон поиска в командной строке сопоставляется со всеми _регулярными\_соответствиями_ из этого списка в заданном порядке. Для первого сопоставления по умолчанию используется соответствующее _поле\_соответствия_. Вы можете указать последнее _поле\_соответствия_ (без _регулярного\_выражения_) в этом списке - оно используется как резервное в случае, если соответствий не было обнаружено; если такой записи не существует, по умолчанию принимается **name**. Чтобы дополнительно не экранировать символы вручную, может быть удобно использовать отложенную замену ${\\ПЕРЕМЕННАЯ} для _регулярного\_выражения_.

Для _поля\_соответствия_ допустимы значения: **name**, **category**, **category/name** (или **category-name**), **description**, **license**, **homepage**, **provide**, **virtual**, **set**, **slot**, **installed-slot**, **use** (или **iuse**), **with-use** (или **installed-with-use**), **without-use** (или **installed-without-use**). Они соответствуют аналогичным консольным опциям для поля соответствия. Специальное значение **virtual** совмещает в себе две опции командной строки - **-A** и **-P**.

**DEFAULT\_MATCH\_ALGORITHM** **(список строк)**

Это список строк вида _регулярное\_выражение_\[\\n\\r\\t \]_алгоритм\_соответствия_, который используется для определения стандартного алгоритма соответствия. Аналогично **DEFAULT\_MATCH\_FIELD** с тем отличием, что _алгоритм\_соответствия_ указывает на предпочитаемый алгоритм соответствия. _алгоритм\_соответствия_ может принимать значения **regex**, **pattern**, **substring**, **begin**, **end**, **exact**, **fuzzy**. Они соответствуют аналогичным консольным опциям для алгоритма соответствия. Если не указано другого алгоритма соответствия по умолчанию, будет использоваться **regex**.

**TEST\_FOR\_EMPTY** **(true**/**false)**

Определяет, отображать ли пустые записи в /etc/portage/package.\* с опцией -t.

**TEST\_KEYWORDS** **(true**/**false)**

Определяет, сканировать ли /etc/portage/package.keywords с помощью опции -t.

**TEST\_MASK** **(true**/**false)**

Определяет, сканировать ли /etc/portage/package.mask с помощью опции -t.

**TEST\_UNMASK** **(true**/**false)**

Определяет, сканировать ли /etc/portage/package.unmask с помощью опции -t.

**TEST\_USE** **(true**/**false)**

Определяет, сканировать ли /etc/portage/package.use с помощью опции -t.

**TEST\_ENV** **(true**/**false)**

Определяет, сканировать ли /etc/portage/package.env с помощью опции -t.

**TEST\_CFLAGS** **(true**/**false)**

Определяет, сканировать ли /etc/portage/package.cflags с помощью опции -t.

**TEST\_REMOVED** **(true**/**false)**

Определяет, сканировать ли удаленные пакеты с помощью опции -t.

**TEST\_FOR\_NONEXISTENT** **(true**/**false)**

Определяет, считать ли несуществующие установленные версии удовлетворяющими проверке с помощью опции -T. Определение несуществующих версий содержится в переменных **NONEXISTENT\_IF**.

**TEST\_FOR\_REDUNDANCY** **(true**/**false)**

Определяет, считать ли повторяющиеся записи в /etc/portage/package.\* удовлетворяющими проверке с помощью опции -T. Определение повторяющихся записей содержится в переменных **REDUNDANT\_IF**.

**ACCEPT\_KEYWORDS\_AS\_ARCH** **(full**/**true**/**false)**

Если переменная имеет значение full или true, значение ARCH будет изменено через ACCEPT\_KEYWORDS. Эта переменная определяет, какие ключевые слова считать ARCH и OTHERARCH. Значение full изменяет также исходные ключевые слова ARCH.

**NONEXISTENT\_IF\_OTHER\_OVERLAY** **(true**/**false)**

Определяет, считать ли версии несуществующими для TEST\_FOR\_NONEXISTENT, если они из другого оверлея, нежели установленная версия.

**NONEXISTENT\_IF\_MASKED** **(true**/**false)**

Определяет, считать ли замаскированные версии несуществующими для TEST\_FOR\_NONEXISTENT.

**REDUNDANT\_IF\_DOUBLE** **(строка)**

Справедливо, если /etc/portage/package.keywords содержит повторы ключевых слов длянекоторых/всех ((не)установленных) версий.

**строка** описывает версии, которые будут подвергнуты обработке. Она может иметь следующие значения:

**no** или **false**

Не проверять на подобную избыточность.

**some**

Сигнализировать об избыточности некоторых версий в базе данных.

**all**

Сигнализировать только об избыточности всех версий в базе данных.

**some-installed**

Сигнализировать об избыточности некоторых установленных версий в базе данных. Неустановленные версии будут проигнорированы.

**all-installed**

Сигнализировать только об избыточности всех установленных версий в базе данных. Если версия не установлена, она должна быть указана хотя бы один раз.

**some-uninstalled**

Сигнализировать об избыточности некоторых неустановленных версий в базе данных. Установленные версии будут проигнорированы.

**all-uninstalled**

Сигнализировать только об избыточности всех неустановленных версий в базе данных. Если версия установлена, она должна быть указана хотя бы один раз.

**-** _один\_из\_перечисленных\_вариантов_ или **+** _один\_из\_перечисленных\_вариантов_

Проверка имеет смысл, только если дополнительно не установлено ни одной версии пакета (для **-**) или, соответственно, установлена по крайней мере одна версия (для **+**).

_один\_из\_перечисленных\_вариантов_ **or** _один\_из\_перечисленных\_вариантов_

Результат общей проверки считается положительным, если результативна хотя бы одна частная проверка. Вместо оператора "**or**" дизъюнкция может записываться как "**|**" или "**||**".

**REDUNDANT\_IF\_DOUBLE\_LINE** **(строка)**

Справедливо, если /etc/portage/package.keywords содержит две одинаковых строки для одного адресата; в этом случае portage должен отбросить первую из этих двух строк. Заметьте, что строки, адресованные **foo/bar** и **=foo/bar-1**, portage (а вслед за ним eix) не будет считать совпадающими, даже если **foo/bar** относится к версии **1**. Для обнаружения повтора в этом последнем, неявном случае можно использовать **REDUNDANT\_IF\_DOUBLE\_LINE**, **REDUNDANT\_IF\_MIXED** и **REDUNDANT\_IF\_STRANGE**.

**REDUNDANT\_IF\_MIXED** **(string**, см. ниже**)**

Справедливо, если /etc/portage/package.keywords содержит два различных ключевых слова, например, ~ARCH и -\*, для релевантных версий.

**REDUNDANT\_IF\_WEAKER** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.keywords для релевантных версий содержит ключевое слово, которое может быть заменено менее жестким ключевым словом - например, -\* или ~OTHERARCH или OTHERARCH вместо ~ARCH, или ~OTHERARCH вместо OTHERARCH.

**REDUNDANT\_IF\_STRANGE** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.keywords для релевантных версий содержит постороннее ключевое слово, например, UNKNOWNARCH (неизвестно .ebuild-сценарию и ARCH) или -OTHERARCH.

**REDUNDANT\_IF\_MINUSASTERISK** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.keywords содержит запись -\*. Эта проверка имеет смысл, только если переменная **OBSOLETE\_MINUSASTERISK** имеет значение false.

**REDUNDANT\_IF\_NO\_CHANGE** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.keywords предоставляет ключевые слова, которые не изменяют состояние ключевых слов доступности для релевантных версий.

**REDUNDANT\_IF\_MASK\_NO\_CHANGE** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.mask содержит записи, которые не меняют статус маскировки для релевантных версий.

**REDUNDANT\_IF\_UNMASK\_NO\_CHANGE** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.unmask содержит записи, которые не меняют статус маскировки для релевантных версий.

**REDUNDANT\_IF\_DOUBLE\_MASKED** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.mask содержит две одинаковых записи для релевантных версий.

**REDUNDANT\_IF\_DOUBLE\_UNMASKED** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.unmask содержит две одинаковых записи для релевантных версий.

**REDUNDANT\_IF\_DOUBLE\_USE** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.use содержит две одинаковых записи для релевантных версий.

**REDUNDANT\_IF\_DOUBLE\_ENV** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.env содержит две одинаковых записи для релевантных версий.

**REDUNDANT\_IF\_DOUBLE\_CFLAGS** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.cflags содержит две одинаковых записи для релевантных версий. Обратите внимание, что этот файл не поддерживается portage, но вы, возможно, обеспечили его поддержку в вашей личной конфигурации /etc/portage/bashrc. Естественно, это означает и то, что формат для /etc/portage/package.cflags не определен. eix подразумевает, что формат его аналогичен /etc/portage/package.{keywords,use} (т.е. по одной записи на строку, версии, отвечающие критерию, в начале). Как и другие файлы /etc/portage/package.\*, /etc/portage/package.cflags может представлять собой и каталог; в таком случае все находящиеся в нем нескрытые файлы/подкаталоги обрабатываются рекурсивно, разрешаются символические ссылки.

**REDUNDANT\_IF\_IN\_KEYWORDS** **(строка**, см. ниже**)**

Справедливо, если /etc/portage/package.keywords содержит непустую запись для релевантной версии (для обнаружения пустых записей используйте -t). Конечно, никому не придет в голову видеть избыточность во всех совпадениях (хотя возможно использовать эту опцию нерационально, просто для отображения всех совпадений). Однако совпадающие, но не установленные пакеты могут рассматриваться как избыточные. Поэтому этой переменной, как правило, присваивают значение **-some** или аналогичное ему **-some-uninstalled** (либо **false**, если записи для неустановленных пакетов воспринимать как нормальное явление и не считать избыточными).

**REDUNDANT\_IF\_IN\_MASK** **(строка**, см. ниже**)**

Аналогично **REDUNDANT\_IF\_IN\_KEYWORDS**, но для /etc/portage/package.mask.

**REDUNDANT\_IF\_IN\_UNMASK** **(строка**, см. ниже**)**

Аналогично **REDUNDANT\_IF\_IN\_KEYWORDS**, но для /etc/portage/package.unmask.

**REDUNDANT\_IF\_IN\_USE** **(строка**, см. ниже**)**

Аналогично **REDUNDANT\_IF\_IN\_KEYWORDS**, но для /etc/portage/package.use.

**REDUNDANT\_IF\_IN\_ENV** **(строка**, см. ниже**)**

Аналогично **REDUNDANT\_IF\_IN\_KEYWORDS**, но для /etc/portage/package.env.

**REDUNDANT\_IF\_IN\_CFLAGS** **(строка**, см. ниже**)**

Аналогично **REDUNDANT\_IF\_IN\_KEYWORDS**, но для /etc/portage/package.cflags. См. выше комментарии к этому файлу.

**SLOT\_UPGRADE\_FORBID** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.slot\_upgrade\_forbid

**SLOT\_UPGRADE\_ALLOW** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.slot\_upgrade\_allow

**KEYWORDS\_NONEXISTENT** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.accept\_keywords.nonexistent

**MASK\_NONEXISTENT** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.mask.nonexistent

**UNMASK\_NONEXISTENT** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.unmask.nonexistent

**USE\_NONEXISTENT** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.use.nonexistent

**ENV\_NONEXISTENT** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.env.nonexistent

**CFLAGS\_NONEXISTENT** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.cflags.nonexistent

**INSTALLED\_NONEXISTENT** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.installed.nonexistent

**PACKAGE\_NOWARN** **(список строк)**

Перечень имен файлов/каталогов, которые используются как /etc/portage/package.nowarn

### /etc/portage/sets.eix[¶](#-etcportagesetseix)

Каталог, аналогичный **/etc/portage/sets** (см. справочную страницу portage). Поскольку portage располагает несколькими способами определения сетов пакетов, недоступными eix, вы можете использовать этот каталог для хранения сетов (статических), чтобы eix мог их опознать (чтобы записи для сетов в /etc/portage/package.keywords корректно обрабатывались).

### /etc/portage/package.slot\_upgrade\_forbid[¶](#-etcportagepackageslot_upgrade_forbid)

### /etc/portage/package.slot\_upgrade\_allow[¶](#-etcportagepackageslot_upgrade_allow)
Аналогично другим адресам /etc/portage/package.\*, могут быть как файлами, так и каталогами. Записи в них имеют вид _категория/пакет_ (по записи на строку). Соответствующие записям пакеты рассматриваются как исключения для переменной **UPGRADE\_TO\_HIGHEST\_SLOT**. 

### /etc/portage/package.accept\_keywords.nonexistent[¶](#-etcportagepackageaccept_keywordsnonexistent)

### /etc/portage/package.keywords.nonexistent[¶](#-etcportagepackagekeywordsnonexistent)

### /etc/portage/package.mask.nonexistent[¶](#-etcportagepackagemasknonexistent)

### /etc/portage/package.unmask.nonexistent[¶](#-etcportagepackageunmasknonexistent)

### /etc/portage/package.use.nonexistent[¶](#-etcportagepackageusenonexistent)

### /etc/portage/package.env.nonexistent[¶](#-etcportagepackageenvnonexistent)

### /etc/portage/package.cflags.nonexistent[¶](#-etcportagepackagecflagsnonexistent)
Аналогично другим адресам /etc/portage/package.\*, могут быть как файлами, так и каталогами. Разделителем записей служит либо пробел, либо новая строка. Если какая-либо запись совпадает с первым словом в строке соответствующего файла /etc/portage/package.{keywords,mask,unmask,use,cflags}, данная строка не будет проверяться опцией -t (на предмет имен, отсутствующих в базе данных). Так вы можете избежать некоторых предупреждений при использовании -t. 

### /etc/portage/package.installed.nonexistent[¶](#-etcportagepackageinstallednonexistent)
Аналогичен другим файлам/каталогам /etc/portage/package.\*.nonexistent с той разницей, что не будут выводится сообщения опции -t об установленных пакетах, которые были удалены из базы данных. Записи в этом файле имеют вид _категория/пакет_, но категорию можно и опустить (хотя это не рекомендуется). 

### /etc/portage/package.nowarn[¶](#-etcportagepackagenowarn)
Аналогично другим адресам /etc/portage/package.\*, может быть как файлом, так и каталогом. Позволяет отключать проверку -T для отдельных пакетов. Формат файла совпадает с форматом /etc/portage/package.use с той разницей, что существует возможность включения/отключения проверки. Учитываться будут те строки, для которых имеется хотя бы одно соответствие. Так, если он содержит строки:

**sys-kernel/\*-sources no\_change weaker**

**\>sys-kernel/hardened-sources-2.6.40 -weaker**

опция -T не обнаружит пакет sys-kernel/\*-sources только потому, что активен ключ **REDUNDANT\_IF\_NO\_CHANGE** или **REDUNDANT\_IF\_WEAKER**. Исключение из правила делается для **REDUNDANT\_IF\_WEAKER** и для hardened-sources только в том случае, если доступная версия пакета на ниже 2.6.40\. Записи в файле могут располагаться в произвольном порядке; в случае вхождения символа "-" он всегда имеет приоритет.

В данном файле вы можете указывать один пакет несколько раз. В этом случае будут проверяться вместе все условия, определенные для одного пакета.

Доступные критерии проверки: **in\_keywords**, **no\_change**, **double**, **mixed**, **weaker**, **minusasterisk**, **double\_line**, **in\_mask**, **mask\_no\_change**, **double\_masked**, **in\_unmask**, **unmask\_no\_change**, **double\_unmasked**, **in\_use**, **double\_use**, **in\_env**, **double\_env**, **in\_cflags**, **double\_cflags**. По смыслу они идентичны соответствующим переменным **REDUNDNANT\_IF\_\***.

Дополнительно можно использовать критерии **nonexistent**, **masked**, **other\_overlay**, по смыслу идентичные, соответственно, **TEST\_FOR\_NONEXISTENT**, **NONEXISTENT\_IF\_MASKED**, **NONEXISTENT\_IF\_OTHER\_OVERLAY**.

### /var/cache/eix[¶](#-varcacheeix)

Это бинарная база данных eix. При необходимости адрес можно изменить с помощью переменной **EIX\_CACHEFILE** (по умолчанию она соотносится с **EPREFIX**, используя механизм отложенного обращения). Но для обеспечения проверки отдельных привилегий перед выполнением **eix-update** необходимо использовать стандартный путь /var/cache/eix.

## versionsort[¶](#versionsort)

**versionsort** представляет собой вспомогательный инструмент для обработки сценариев и имеет двоякое назначение. Сначала он отсекает информацию о версии от аргументов либо интерперетирует сами аргументы как строки версий (в зависимости от используемой эвристической процедуры). Затем он отображает собранные строки версий упорядоченным списком, согласно правилам сортировки версий, принятым для portage. Если аргументов несколько, каждая версия (включая последнюю) завершается переходом на новую строку. Так, команда

**versionsort gcc-4.4 4.4\_alpha0 sys-devel/gcc-4.05 4.5**

выведет следующее:

**4.05**

**4.4\_alpha0**

**4.4**

**4.5**

Если вы передаете утилите только один аргумент, eix менее жестко подходит к обработке версий: даже если строка версии не вполне корректна, выводимые строки гарантированно будут соответствовать обработанным строкам версий. Вы можете включать в сценарии запуск versionsort с одним аргументом, чтобы отделить имя пакета от версии, например

**split=1-font-adobe-75dpi-1.3-r1**

**version=\`versionsort "X${split}"\`; name=${split%"-${version}"}**

Хотя в настоящее время разницы нет, надежнее в таком случае (принимая во внимание, что в будущем возможно расширение формата версии), если аргумент(ы) начинается/-ются не с числа (**X** в приведенном примере), дабы гарантировать, что versionsort действительно отделяет версию от аргумента, а не принимает за версию весь аргумент целиком.

## ОШИБКИ (+ ЧАВО)[¶](#ОШИБКИ-ЧАВО)

Об обнаруженных ошибках либо сообщайте напрямую девелоперам eix: _[http://developer.berlios.de/projects/eix/](http://developer.berlios.de/projects/eix/)_, либо оставьте заявку на багтрекере Gentoo: _[http://bugs.gentoo.org/](http://bugs.gentoo.org/)_.

eix не поддерживает и, вероятно, никогда не будет поддерживать обработку зависимостей и/или USE-флагов. Это, в частности, означает, что вывод eix -u в целом будет отличаться от вывода emerge update; для нормального функционирования системы ориентироваться следует на последний. Прежде всего это справедливо для обновления пакетов со слотами. Переменная **UPGRADE\_TO\_HIGHEST\_SLOT** и исключения, вручную установленные в **/etc/portage/package.slot\_upgrade\_forbid** либо, соответственно, в **/etc/portage/package.slot\_upgrade\_allow**, могут помочь частично обойти эти неудобства.

eix не обеспечивает и планирует обеспечивать полную поддержку всех поддерживаемых portage сетов. В настоящее время не предполагается, что eix когда либо будет поддерживать даже рекомендуемые настройки PROPERTIES=set для помещения пакетов в дерево (поскольку для их успешной обработки утилите потребовалась бы полная поддержка зависимостей и USE-флагов). В качестве временного решения вы можете вручную определить дополнительные сеты в **/etc/portage/sets.eix**. Далее, eix не поддерживает и, вероятно, не будет поддерживать обращение к файлам sets.conf. Если вы указывали дополнительные каталоги **sets/**, например, в каком-либо оверлее, вы должны добавить эти каталоги, вручную изменив значение переменной **EIX\_LOCAL\_SETS** в файле /etc/eixrc. Проще всего будет поместить в /etc/eixrc запись вида
**EIX\_LOCAL\_SETS\_ADD="**_/путь/к/оверлею1/sets_ _/путь/к/оверлею2/sets_ _..._**"**

(см. выше описание **EIX\_LOCAL\_SETS**).

eix-diff никогда не обращается к /etc/portage/profile. (Это объясняется тем, что сохраненная база данных содержит только сведения о маскировке в исходном профиле, но не сам профиль. С другой стороны, /etc/portage/profile может быть интерпретирован, только если профиль известен.)

Если вы хотите использовать номер оверлея в какой-либо переменной/команде с аргументами eix, вывод с применяемым по умолчанию **OVERLAYS\_LIST=all-used-renumbered** неудобен.

Не существует настройки метода кэширования, которая позволяла бы получать информацию из оверлеев (для таковых метаданные кэша портежей недоступны) одновременно с высокой скоростью и надежностью - вам всегда приходится выбирать между ними. Стандартно система предпочитает режим максимальной скорости, но при этом зачастую некорректно отображаются слоты и возникают другие проблемы.

Всегда непросто работать с **EPREFIX**/**ROOT**. В частности, уже в силу поддержки множества таких переменных, eix не может не быть подвержен локальным атакам, если его вызывать из потенциально небезопасного окружения.

Для многих было неудобно принятое ранее по умолчанию значение **KEEP\_VIRTUALS=true**. Однако с новым, отрицательным значением, сомнительно, что кто-либо вообще обнаружит такую возможность. :(

Для переменной **OBSOLETE\_MINUSASTERISK** не существует значения по умолчанию, которое удовлетворяло бы пользователей как старых, так и новых версий portage.

Eix обладает настолько широким функционалом, что документация по нему и, соответственно, настройка с течением времени чрезвычайно усложнились. И тем не менее многие параметры по-прежнему не поддаются конфигурированию...

## ИСТОРИЯ[¶](#ИСТОРИЯ)

Изначально утилита **eix** существовала под названием **portagedb**. Переименована она была во избежание двусмысленности - в составе portage уже имелся инструмент portagedb.

В первых версиях функционал eix-update обеспечивался вызовом eix с ключом -u. Затем для облегчения сопровождения он был отделен, и появилась **update-eix**. В конечном итоге исполняемый файл был сохранен, его назначение определяется командой вызова, а оригинальное название, update-eix, превратилось в **eix-update**.

Утилита **eix-diff** сначала также именовалась иначе, а именно **diff-eix**. Нынешняя **eix-remote** была известна как **update-eix-remote**, **eix-layman** - как **update-eix-layman**, а **eix-functions.sh** - как **functions-eix.sh** (а в изначальной версии - как **update-eix-functions.sh**). Все эти переименования преследовали цель создать логично организованный набор утилит: все программы, идущие с eix, теперь имеют префикс eix-\* (за исключением **versionsort**, которая, в общем-то, представляет собой самостоятельный инструмент). Если вам непривычна эта новая схема именования или если вы используете сценарии, зависящие от прежних имен переменных, вы можете использовать символические ссылки на оригинальные имена; такое поведение полностью поддерживается и не будет отменено. Если вы вызываете eix' **./configure** с опцией **--enable-obsolete-symlinks** или **--enable-obsolete-reminder**, такие ссылки (или обертки, которые также напоминают об устаревших именах) создаются автоматически - хотя и не по умолчанию, ведь новым пользователям эта возможность не нужна. Мы рекомендуем обновить ваши сценарии, заменив в них имена обрабатываемых переменных на новые, чтобы их можно было выполнять и на свежих системах. Кроме того, в **eix-functions.sh** по соображениям логики были переименованы две переменные (**CallUpdateEix** -\> **CallUpdate** и **ClearUpdateEixArgs** -\> **ClearUpdateArgs**); была переименована и внутренняя переменная, к которой они обращаются (но ее никогда не предполагалось использовать в сценариях). Если вы всё еще используете какую-либо из перечисленных опций **./configure**, будет установлена также обертка для **functions-eix.sh**, поддерживающая устаревшие имена функций (и выдающая предупреждение, когда они используются с включенной опцией **--enable-obsolete-reminder**).
Начиная с eix-0.8.0, где был введен синтаксис %{\*VARIABLE}, нет смысла использовать разные имена переменных для eix и eix-diff. Поэтому соответствующие **DIFF\_\*** -переменные исчезли. 

Метод кэширования **metadata-flat** ранее именовался **metadata**. Метод кэширования **assign** ранее именовался **backport** или **portage-2.1**. Метод кэширования **flat** носил имя **portage-2.0**, его и предпочитали употреблять. Несмотря ни на что, устаревшие имена продолжают поддерживаться.

portage-2.1 и portage-2.1.1 не удаляют старого кэша зависимостей, поэтому при использовании метода кэширования **flat**/**assign** eix может обнаружить пакеты, которые уже не в дереве портежей. Чтобы обойти это поведение, eix-sync ранее удалял сохраненный прежде кэш (rm -rf /var/cache/edb/dep/\*). Поскольку большинство пользователей уже не нуждаются в данном методе кэширования, а удаление старого кэша замедлит следующий запуск portage, оно было исключено из стандартных настроек (но по-прежнему доступно как опция, которую можно прописать в /etc/eix-sync.conf).

Прежде eix-sync по умолчанию работал с gensync instead, а не с layman. Если вы хотите использовать gensync, несмотря на то, что он устарел, см. описание /etc/eix-sync.conf.

eix-sync более не поддерживает журналирование; опции -v и -V были удалены. Это позволяет избежать таких проблем как отсутствие видимого вывода при выставленном EMERGE\_DEFAULT\_OPTS=--ask. Сейчас, если вы хотите вызывать eix-sync по расписанию, используйте перенаправление.

Механизм, который теперь описывается переменной **DEFAULT\_MATCH\_FIELD**, изменился. Использовавшиеся ранее переменные **MATCH\_.\*\_IF** и **MATCH\_ORDER** (обладавшие меньшими возможностями) теперь не поддерживаются.

Переменные **ADD\_CACHE\_METHOD** и **ADD\_OVERRIDE\_CACHE\_METHOD** более не являются встроенными, а используются, если не указано иное, при отложенной замене при стандартных **CACHE\_METHOD** и **OVERRIDE\_CACHE\_METHOD**. В частности, настройка переменных в файле **/etc/eixrc** без добавления отложенной замены "**%{ADD\_CACHE\_METHOD}**" или, соответственно, "**%{ADD\_OVERRIDE\_CACHE\_METHOD}**", лишает смысла применявшиеся ранее переменные.

В версиях eix ниже 0.18.0, такие параметры пользовательского отображения версий как **<installedversions:**_ПЕРЕМЕННАЯ_**\>** или **<availableversions:**_ПЕРЕМЕННАЯ_**\>** не существовали. Выполнение сопоставленных им функций возлагалось на ряд разрозненных параметров для **<installedversions:\*\>** и набор вариантов вывода списка доступных или установленных версий для вызова из сценариев, подобных **<fullvailableversions\>**. Все они были упразднены, а на смену им пришли переменные **NAMEVERSIONS**, **EQNAMEVERSION**, **ANAMESLOT**, **ANAMEASLOT**, **NAMESLOT**, **NAMEASLOT** и **DATESORT** (причем **DATESORT** предоставляет сравнительный пример, ранее недоступный). См. описание этих переменных в выводе команды **eix --dump**. Чтобы испытать эффект от их использования, попробуйте, например, выполнить:

**eix --format '<availableversions:ANAMESLOT:ANAMESLOT\>' --pure-packages gcc**

См. также комментарии к опции **-I**.

Начиная с версии eix 0.20.0, логические связки _ВЫРАЖЕНий_ претерпели серьезные изменения: теперь они не только допускают скобки, но и цепочки с операторами **-a** и **-o** интуитивно имеют левую ассоциативность. Отрицание **--not** теперь обрабатывается как логическая операция, начинающая новый ФИГУРНАЯ\_СКОБКА\_ИЛИ\_ПРОВЕРКА, и не рассматривается как часть КРИТЕРИЕВ\_ПРОВЕРКИ (многим пользователям было трудно это воспринимать). Теперь **--pipe** действительно входит в состав КРИТЕРИЕВ\_ПРОВЕРКИ и не подразумевает использования логических связок.
Начиная с eix-0.20.1, все ранее использовавшиеся файлы /etc/portage/package.\*.nowarn уже не поддерживаются по умолчанию: все их заменил один файл file/dir /etc/portage/package.nowarn. Если вы хотите продолжать использовать множественные файлы .nowarn, установите значение переменной окружения **OBSOLETE\_NOWARN=true**. Подробнее см. в описании переменной **PACKAGE\_NOWARN** (в выводе **eix --dump**).

В версия **eix** ниже 0.22.4 **eix-installed** входил в состав **eix-test-obsolete**, что было неудобно и для пользователей, и для обеспечения сопровождения, поскольку эти две утилиты имеют совершенно различное назначение.

## АВТОРЫ[¶](#АВТОРЫ)

* Martin V\\(:ath <[vaeth@mathematik.uni-wuerzburg.de](mailto:vaeth@mathematik.uni-wuerzburg.de)\> (разработчик, текущее сопровождение)

* Emil Beinroth <[emilbeinroth@gmx.net](mailto:emilbeinroth@gmx.net)\> (разработчик, ранее обеспечивал сопровождение)

* Wolfgang Frisch <[xororand@users.sourceforge.net](mailto:xororand@users.sourceforge.net)\> (неактивный разработчик, автор первой версии eix)

* Roland Wittmann <[linuxcommando@users.sourceforge.net](mailto:linuxcommando@users.sourceforge.net)\> (неактивный разработчик)

## СМ. ТАКЖЕ[¶](#СМ-ТАКЖЕ)

**[portage](.html)**(5), **fnmatch**(3), **regex**(7), **[emerge](.html)**(1), **esearch**(1), **[qsearch](.html)**(1), **[layman](.html)**(8)

На домашней странице eix, _[http://eix.berlios.de/](http://eix.berlios.de/)_, содержится дополнительная информация и ссылки.

## ПЕРЕВОД[¶](#ПЕРЕВОД)

* Елена Гаврилова <[e.vl.gavrilova@yandex.ru](mailto:e.vl.gavrilova@yandex.ru)\>

  
23 марта 2011