<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>calculate utilities templates</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style>
body { font:80% Verdana,Tahoma,Arial,sans-serif; }
h1, h2, h3, h4 {  font-family: "Trebuchet MS",Georgia,"Times New Roman",serif; }
ul.toc { padding: 4px; margin-left: 0; }
ul.toc li { list-style-type:none; }
ul.toc li.heading2 { margin-left: 1em; }
ul.toc li.heading3 { margin-left: 2em; }
a.wiki-anchor { display: none; margin-left: 6px; text-decoration: none; }
a.wiki-anchor:hover { color: #aaa !important; text-decoration: none; }
h1:hover a.wiki-anchor, h2:hover a.wiki-anchor, h3:hover a.wiki-anchor { display: inline; color: #ddd; }
pre {font-size:133% }
</style>
</head>
<body>
<h1 id="Шаблоны-Calculate">Шаблоны Calculate<a href="#Шаблоны-Calculate" class="wiki-anchor">&para;</a></h1>


	<ul class="toc"><li class="heading1"><a href="#Шаблоны-Calculate">Шаблоны Calculate</a></li>
<li class="heading2"><a href="#Введение">Введение</a></li>
<li class="heading3"><a href="#Особенности-работы-с-шаблонами">Особенности работы с шаблонами</a></li>
<li class="heading2"><a href="#Шаблоны-установки">Шаблоны установки</a></li>
<li class="heading3"><a href="#Форматы-файлов">Форматы файлов</a></li>
<li class="heading3"><a href="#Управляющие-элементы">Управляющие элементы</a></li>
<li class="heading3"><a href="#Способы-объединения">Способы объединения</a></li>
<li class="heading2"><a href="#Расположение">Расположение</a></li>
<li class="heading3"><a href="#Правила-именования-файлов">Правила именования файлов</a></li>
<li class="heading3"><a href="#Правила-именования-директорий">Правила именования директорий</a></li>
<li class="heading3"><a href="#Права-доступа">Права доступа</a></li>
<li class="heading3"><a href="#Символические-ссылки">Символические ссылки</a></li>
<li class="heading2"><a href="#Схема-объединения">Схема объединения</a></li>
<li class="heading3"><a href="#Правила-объединения">Правила объединения</a></li>
<li class="heading3"><a href="#Правила-объединения-действующие-по-умолчанию">Правила объединения, действующие по умолчанию</a></li>
<li class="heading3"><a href="#Изменение-правил-объединения">Изменение правил объединения</a></li>
<li class="heading2"><a href="#Формат-CXmlConf">Формат CXmlConf</a></li>
<li class="heading3"><a href="#Области">Области</a></li>
<li class="heading3"><a href="#Переменные">Переменные</a></li>
<li class="heading3"><a href="#Списки">Списки</a></li>
<li class="heading3"><a href="#Разделённые-списки">Разделённые списки</a></li>
<li class="heading3"><a href="#Комментарии">Комментарии</a></li>
<li class="heading3"><a href="#Управляющие-элементы">Управляющие элементы</a></li>
<li class="heading2"><a href="#Формат-XML">Формат XML</a></li>
<li class="heading3"><a href="#Поддерживаемые-форматы-XML">Поддерживаемые форматы XML</a></li>
<li class="heading3"><a href="#Отличия-от-формата-CXmlConf">Отличия от формата CXmlConf</a></li>
<li class="heading3"><a href="#Объединение-элементов-XML">Объединение элементов XML</a></li>
<li class="heading3"><a href="#Примеры-использования">Примеры использования</a></li>
<li class="heading2"><a href="#Формат-patch">Формат 'patch'</a></li>
<li class="heading3"><a href="#Особенности">Особенности.</a></li>
<li class="heading3"><a href="#Описание">Описание.</a></li>
<li class="heading2"><a href="#Формат-diff">Формат 'diff'</a></li>
<li class="heading2"><a href="#Формат-kernel">Формат 'kernel'</a></li>
<li class="heading2"><a href="#Формат-dconf">Формат 'dconf'</a></li>
<li class="heading2"><a href="#Формат-json">Формат 'json'</a></li>
</ul>


	<h2 id="Введение">Введение<a href="#Введение" class="wiki-anchor">&para;</a></h2>


	<p>Традиционно в ОС Linux настройки приложений хранятся в текстовых файлах, как правило в директории <code>/etc</code>, реже в <code>/var</code>. Форматы таких конфигурационных файлов различаются: от простых "переменная=значение", до более сложных C-подобных конструкций, либо составленных в XML.</p>


	<p>Простой на первый взгляд подход обеспечивает исключительную стабильность в работе приложений, так как за сохранность настроек отвечает исключительно файловая система.</p>


	<p>Различные дистрибутивы Linux, как правило, предлагают свои программы настройки приложений. К сожалению, такой подход, имея неоспоримое преимущество в удобстве, имеет также ряд недостатков:</p>


	<ul>
	<li>пользователь привязывается к определенной программе настройки (дистрибутиву);</li>
		<li>количество настроек, как правило, ограничено интерфейсом программы;</li>
		<li>прямое редактирование настроек становится затруднительным, т.к. программа переписывает файл при внесении изменений.</li>
	</ul>


	<h3 id="Особенности-работы-с-шаблонами">Особенности работы с шаблонами<a href="#Особенности-работы-с-шаблонами" class="wiki-anchor">&para;</a></h3>


	<p>В утилитах Calculate 2 и 3 подход к шаблонам был существенно переработан и обладает рядом отличий от первой версии:</p>


	<ul>
	<li>Основной метод переноса шаблонов - объединение с конфигурационными файлами системы. При этом поддерживаются все популярные форматы файлов.</li>
		<li>Объединение шаблона с конфигурационным файлом производится посредством конвертации в XML формат. При этом формат файла шаблона может отличаться от конфигурационного файла.</li>
		<li>Файл шаблона может содержать заголовок, описывающий методы объединения.</li>
		<li>Имена встроенных переменных переименованы согласно типу.</li>
	</ul>


	<h2 id="Шаблоны-установки">Шаблоны установки<a href="#Шаблоны-установки" class="wiki-anchor">&para;</a></h2>


	<p>Программа Calculate заменяет прямое редактирование файлов настроек на создание шаблонов.</p>


	<h3 id="Форматы-файлов">Форматы файлов<a href="#Форматы-файлов" class="wiki-anchor">&para;</a></h3>


Согласно методу хранения данных, файлы шаблонов могут иметь один из перечисленных форматов:
	<ul>
	<li><strong>apache, kde, bind, postfix, proftpd, samba, procmail, ldap, dovecot, xml_xfce, xml_xfcepanel, xml_gconf, xml_gconf_tree, compiz, plasma, squid, dhcp, openrc</strong> - форматы файлов настроек распространенных приложений</li>
		<li><strong>bin</strong> - двоичный формат файлов</li>
		<li><strong>raw</strong> - сырой текст</li>
		<li><strong>patch</strong> - шаблон для применения регулярных выражений (использует специальный вид объединения <em>patch</em>).</li>
	</ul>


	<p>Для формата kde не обрабатываются параметры '-','+' для элементов внутри области.</p>


	<p>Названия параметров в openrc-формате нечувствительны к регистру букв.</p>


	<h3 id="Управляющие-элементы">Управляющие элементы<a href="#Управляющие-элементы" class="wiki-anchor">&para;</a></h3>


	<p>Помимо настроек сервисов, записанных в оригинальном формате программы, файлы шаблонов содержат служебные записи, которые условно можно разделить на несколько типов.</p>


	<h4>Переменная</h4>


	<p>Переменная - текстовый элемент в шаблоне, имеющий имя, который заменяется в соответствующем конфигурационном файле значением.</p>


Переменная имеет имя, значение, область действия.
	<ul>
	<li>имя - латинские буквы и цифры</li>
		<li>значение - текст для замены (создается в программе)</li>
		<li>область действия - действует глобально для всех шаблонов или локально для одного</li>
	</ul>


	<p>Переменные подразделяются на переменные шаблонов и переменные функций.</p>


	<p>У переменных шаблонов глобальная область действия, то есть любая переменная шаблона, доступная программе, может быть использована в любом шаблоне. Значение переменной нельзя изменить в шаблоне.</p>


	<p>Переменные функций могут быть созданы в шаблоне; также можно изменить значение переменной в шаблоне. Область действия переменной функции - текущий шаблон.</p>


	<p>Для передачи значений переменных функций из текущего шаблона в другой шаблон используется стек переменных функций шаблонов (LIFO), в который при помощи функции шаблонов <code>push()</code> записывается значение из текущего шаблона, а функцией шаблона <code>pop()</code> получаем значение в другом шаблоне.</p>


	<h4>Стек переменных функций шаблонов</h4>


	<p>Стек (LIFO - "последним пришел, первым вышел") для хранения значений переменных функций. Доступен глобально для всех шаблонов, для работы используются функции шаблонов, <code>push()</code> - запись, <code>pop()</code> - чтение. Запись и чтение возможны как в одном шаблоне, так и в разных.</p>


	<h4>Заголовок</h4>


	<p>Заголовок - управляющая запись шаблона, определяющая методы переноса шаблона в систему. Заголовок шаблона записывается первой строкой файла и имеет следующий вид:</p>


<pre>
# Calculate параметр1=значение1 параметр2 [параметр3=значение3 ...]
</pre>

	<p>Содержимое заголовка может быть разбито на строки. В этом случае в конце каждой строки заголовка, кроме последней, должен стоять знак "\" (обратная косая черта).</p>


	<p>Если заголовок отсутствует, настройки файла шаблона определяются исходя из принятых значений по умолчанию.</p>


<strong>Допустимые параметры:</strong><br /><em>Формат</em>
	<ul>
	<li><strong>format=[...]</strong> - формат файла шаблона (см. форматы файлов). По умолчанию формат файла шаблона определяется как "raw", или "bin" для файлов, содержащих двоичные данные.</li>
		<li><strong>comment=[.]</strong> - обозначение начала строкового комментария (пример: "#").</li>
	</ul>


<em>Объединение</em>
	<ul>
	<li><strong>append=[join|before|after|replace|remove|skip|patch|clear]</strong> - способ объединения. По умолчанию способ объединения устанавливается в соответствии с форматом файла. Если append=skip - шаблон пропускается. Если append=clear, в случае шаблона файла конфигурационный файл будет очищен - длина файла 0, а в случае шаблона директории все файлы и директории внутри конфигурационной директории будут удалены.</li>
		<li><strong>force</strong> - удалять существующие файлы перед записью конфигурационного файла. Правило действует по умолчанию, если указан параметр "symbolic".</li>
		<li><strong>link=путь</strong> - путь к конфигурационному файлу, с которым объединяется файл шаблона. По умолчанию путь совпадает.<br />Пример: "link=/etc/conf.d/net.example" </li>
		<li><strong>path=путь</strong> - путь к директории, в которой будет находиться конфигурационный файл</li>
		<li><strong>name=имя</strong> - имя конфигурационного файла</li>
		<li><strong>mirror</strong> - выполнять объединение только в случае существования конфигурационного файла. Если конфигурационный файл задан параметром "link" и он не существует, файл назначения удаляется.</li>
		<li><strong>proteсted</strong> <strong>(добавлено в 3.1.1)</strong> - защитить файл при удалении пакета, которому он принадлежит.</li>
		<li><strong>symbolic</strong> - создать символическую ссылку на файл, указанный параметром "link".</li>
		<li><strong>autoupdate</strong> - при установке любого пакета запускается специальный скрипт <code>cl-update-config</code>, который применяет шаблоны для устанавливаемого пакета. Конфигурационные файлы устанавливаемого пакета защищены. Иными словами, при установке пакета, если такой же файл существует в системе и изменен, он не будет заменен. Замена конфигурационных файлов установленных пакетов производится командой <strong>dispatch-conf</strong>. Если в заголовке шаблона есть параметр <strong>autoupdate</strong> то после применения шаблона конфигурационный файл будет скопирован в систему. Если параметр отсутствует то для переноса измененного конфигурационного файла необходимо использовать  <strong>dispatch-conf</strong>.</li>
		<li><strong>run</strong> <strong>(добавлено в 3.1.1)</strong> - оболочка для выполнения конфигурационного файла, полученного из шаблона. Сценарий выполняется сразу же после обработки этого шаблона.<br />Пример: "run=/bin/bash" </li>
		<li><strong>exec</strong> - оболочка для выполнения конфигурационного файла, полученного из шаблона. Сценарий добавляется в очередь, которая выполняется после обработки всех неисполняемых шаблонов.<br />Пример: "exec=/bin/bash" (начиная с версии 3.1.1 выполняемый сценарий не сохраняется на диск)</li>
		<li><strong>merge</strong> - выполнить в конце настройку перечисленных пакетов.<br />Пример: "merge=openrc,grub" (начиная с версии 3.1.1 пакеты необходимо указывать вместе с категорией <code>merge=sys-apps/openrc,sys-boot/grub</code>)</li>
		<li><strong>postmerge</strong> (добавлено в 3.1.10) - выполнить в конце настройку перечисленных пакетов. В отличие от merge пакеты будут настроены после <code>pkg_postinst()</code> во время сборки пакета.<br />Пример: "postmerge=sys-apps/openrc,sys-boot/grub" </li>
		<li><strong>env</strong> - <strong>(добавлено в 3.1)</strong> использовать в шаблоне переменные указанного модуля. Если модуль в системе отсутствует - шаблон будет пропущен.<br />Пример: "env=install"</li>
	</ul>


<em>Права доступа</em>
	<ul>
	<li><strong>chmod=XXX</strong> - права доступа к конечному файлу (пример: "644"). По умолчанию права соответствуют оригинальному файлу. Если его нет, права соответствуют файлу шаблона.</li>
		<li><strong>chown=user:group</strong> - владелец и/или группа конечного файла (пример: "root:root").</li>
	</ul>


<em>Условия</em>
	<ul>
	<li><strong>переменная[>|<|==|!=|>=|<=]значение ...</strong> - условия переноса файла шаблона в систему. Арифметические операции могут объединяться условием "И" (&#38;) (для версии calculate-lib>=2.2 условие "И" (&#38;&#38;)) и "ИЛИ" (||). Приоритет в данном случае будет отдаваться условию И. Несколько условий, разделённых пробелом будут объединяться условием "И".</li>
	</ul>


	<h4>Метки</h4>


	<p>Вы можете настроить систему исходя из <em>аппаратных требований</em> компьютера, <em>сетевых установок</em> и прочих условий. Для этого в файле шаблона вы можете вместо постоянных значений устанавливать <em>метки</em> переменных.</p>


	<p>Пример файла <code>/etc/conf.d/hostname</code>:</p>


<pre>
HOSTNAME="#-os_net_hostname-#" 
</pre>

	<p>Для использования переменных из другого модуля перед переменной, через точку указывается модуль <strong>(добавлено в 3.1)</strong>:</p>


	<p>Пример:</p>


<pre>
#-install.os_install_root_dev-#
</pre>

	<h4>Условные блоки</h4>


	<p>Файл шаблона может содержать <em>условные блоки</em>.</p>


	<p>Условные блоки - выделенный текст шаблона, подставляемый в случае соответствия <em>регулярного выражения</em>.</p>


	<p><em>Регулярное выражение</em> - метод проверки значений выражений. В качестве значений могут применяться следующие <em>типы данных</em>:</p>


	<ul>
	<li><strong>переменные</strong> - встроенные переменные Calculate.</li>
		<li><strong>числа</strong> - целые и дробные числа, в качестве разделителя дробной части выступает точка ".".</li>
		<li><strong>строки</strong> - буквы, цифры, специальные символы.</li>
		<li><strong>номера версий</strong> - числа и одна или две точки, разделяющих номер версии (например, 8.5.1).</li>
	</ul>


	<p>Методом проверки выступает арифметическая операция <strong>>, <, ==, !=, >=, <=</strong> (больше, меньше, равно, не равно, больше либо равно, меньше либо равно). Тип данных определяется перед операцией сравнения.</p>


	<p>Арифметические операции могут объединяться условием "И" (&#38;) и "ИЛИ" (||). Приоритет в данном случае будет отдаваться условию "И".</p>


	<p>Условный блок должен начинаться с метки "#?переменная1==значение1(...)#" и заканчивается "#переменная1#", записанными в начале строки.</p>


	<p>Пример условного блока файла <code>/etc/make.conf</code>:</p>


<pre>
#?os_arch_march==i686&#38;&#38;os_linux_shortname==CLD#
   CFLAGS="-O2 -march=i686 -pipe" 
   CHOST="i686-pc-linux-gnu" 
#os_arch_march#
</pre>

	<p>В приведенном примере сравниваются переменные <code>setup_march</code> и <code>setup_sys_shortname</code> со строковыми значениями "i686" и "CLD" соответственно. В случае, если значения обоих переменных совпадают, текст блока будет подставлен в результирующий файл.</p>


	<h4>Функции</h4>


	<p>Для формирования сложных файлов, требующих вычисления во время обработки, служат функции. Подобно переменным, функции вставляются в текст шаблона при помощи конструкции <code>"#-функция()-#"</code>.</p>


	<p>Функции, использующие в аргументах путь к файлу (<strong>path</strong>), могут использовать в качестве домашней директории пользователя '~'</p>


	<p>Доступные функции:</p>


	<p><strong>belong - (не используется начиная с 3.1.1)</strong> - назначение такое же как у merge, за исключением, что она работает только с именем пакета, не учитывая категорию.</p>


	<p><strong>merge([category/pkg_name])</strong> - проверка имени устанавливаемого пакета, если выполняется установка пакета. В остальных случаях функция будет возвращать положительный результат.</p>


	<p>category - категория пакета.<br />pkg_name - имя пакета.</p>


	<p>Если у функции нет аргумента, то именем пакета становится имя шаблона (для директорий - имя директории), категорией - родительская директория. При чем если в имени категории или имени пакета есть версия и/или число для сортировки (20-mc,40-xfce-4.6), то они отбрасываются.</p>


	<p>Примеры:<br /><strong><code>sys-apps/15-portage-2.2/.calculate_directory</code>, category=sys-apps,pkg_name=portage<br /></strong><code>sys-fs/udev</code>, (portage файл), category=sys-fs,pkg_name=udev</p>


Результат зависит от значения переменной шаблона cl_merge_pkg (в версиях ниже 3.1.1 cl_belong_pkg)
	<ul>
	<li>значение cl_merge_pkg - ''
	<ul>
	<li>результат '1', независимо от того, есть или нет аргумент у функции</li>
	</ul>
	</li>
		<li>значение cl_merge_pkg - 'имя_пакета'
	<ul>
	<li>если совпадают значения  cl_merge_pkg и аргумента функции, результат - '1' иначе ''</li>
		<li>если у функции нет аргумента то сравниваются значение cl_merge_pkg и имя директории в которой находится шаблон с функцией merge(), в случае совпадения результат - '1' иначе ''</li>
	</ul></li>
	</ul>


	<p>При выполнении шаблонов для модификации исходного кода пакетов (<code>ac_install_patch</code>) функция в случае положительного результата возвращает номер версии вместо 1.</p>


	<p>Пример. <br />Заголовок шаблона1:<br /><pre>
# Calculate merge(sys-auth/nss_ldap)!=
</pre></p>


	<p>Заголовок шаблона2:<br /><pre>
# Calculate merge(kde-libs/kdm)!=
</pre></p>


	<ol>
	<li>Наложим шаблон для программы sys-auth/nss_ldap: Установим значение переменной cl_merge_pkg равным sys-auth/nss_ldap. Будет применен только шаблон1</li>
		<li>Наложим все шаблоны. Значение переменной cl_merge_pkg по умолчанию - ''. Будут применены шаблон1 и шаблон2.</li>
	</ol>


	<p>Если параметром для merge указан (или определен по пути шаблона) не существующий пакет, то функция возвращает пустое значение.</p>


<strong>case(type,var)</strong> - вывод значения переменной шаблона с изменением регистра символов.<br />где:
	<ul>
	<li><em>type</em> - тип изменения регистра: upper - верхний регистр, lower - нижний регистр, capitalize - первая буква в верхнем регистре.</li>
		<li><em>var</em> - название переменной шаблона.</li>
	</ul>


	<p>Пример. Выведем название хоста в верхнем регистре:<br /><pre>
#-case(upper,os_net_hostname)-#
</pre></p>


	<p><strong>disk(mount_point,name)</strong> - выводит значение параметра жесткого диска при инсталяции системы.<br />Значение функция получает из переменной ('os_install_disk_' + name, если такой не существует, то 'os_disk_'+ name), для поиска нужного значения используется переменная os_install_disk_mount (точки монтирования при инсталяции).</p>


где:
	<ul>
	<li><em>mount_point</em> - точка монтирования при инсталяции.</li>
		<li><em>name</em> - последний элемент переменных начинающихся на os_install_disk_/os_disk ('os_instll_disk_'/'os_disk_' + name).</li>
	</ul>


	<p>значения переменных</p>


	<p>os_install_disk_mount = ['swap', '/', '', '', '/var/calculate']<br />os_disk_grub      ['0,0', '0,1', '0,2', '0,3', '0,4']</p>


	<p>функция<br />disk(/var/calculate,grub)</p>


	<ul>
	<li>в переменной os_install_disk_mount находим /var/calculate, получаем индекс 4</li>
		<li>в переменной os_disk_grub по индексу 4 получаем значение  '0,4'<br />результат функции disk(/var/calculate,grub) '0,4'</li>
	</ul>


	<p>функция<br />disk(/boot,grub)</p>


	<ul>
	<li>в переменной os_install_disk_mount /boot не найден, индекс отсутствует</li>
		<li>если индекс отсутствует, в переменной os_disk_install находим /, получаем индекс 1</li>
		<li>в переменной os_disk_grub по индексу 1 получаем значение  '0,1'<br />результат функции disk(/boot,grub) '0,1'</li>
	</ul>


	<p>Пример. <br />Выведем диск для загрузчика grub:<br /><pre>
#-disk(/boot,grub)-#
</pre></p>


	<p>получаем значение 0,1</p>


	<p><strong>elog(pkg)</strong> - получить отметку времени (timestamp) установки указанного пакета. Если пакет не указан, возвращается время последнего установленного пакета. Информация извлекается из <code>emerge.log</code>. Функция используется для определения необходимости настройки профиля пользователя при входе его в сеанс.</p>


	<p>где:<br />pkg - полное название пакета с категорией</p>


	<p><strong>env(service.var_name)</strong> - чтение значения записанной переменной шаблона сервиса. Информация получается путем обработки файлов хранения значений переменных шаблонов.</p>


где:
	<ul>
	<li><em>service</em> - название сервиса.</li>
		<li><em>var_name</em> - переменная сервиса.<br />разделитель - '.' точка</li>
	</ul>


Примеры:
	<ol>
	<li>прочитаем доменное имя для соединения с jabber сервисом <br /><pre>
#-info(jabber,sr_jabber_host)-#
</pre></li>
	</ol>


	<p>получаем значение jabber.calculate.ru</p>


	<p><strong>exists(path,opt)</strong> - проверка существования файла или директории.</p>


	<p>Если файл или директория существует, выводит '1', иначе ''</p>


	<p>path - путь в файловой системе.<br />opt - необязательная опция.</p>


Возможные значения "opt":
	<ul>
	<li><em>root</em> - путь к файлу не будет содержать chroot-пути. (Какой путь указан, такой будет в действительности - вне зависимости от переменных <code>cl_chroot_path</code> и <code>cl_root_path</code>)</li>
	</ul>


	<p>Пример. Проверим существование директории <code>/etc</code>:<br /><pre>
#-exists(/etc)-#
</pre></p>


	<p>Результатом будет '1'.</p>


	<p><strong>grep(file,regex)</strong> - *(добавлена в 3.3.1) получить значение из файла <code>file</code>, соответствующее регулярному выражению <code>regex</code>. Если в регулярном выражении используется группировка значений, функция возвращает содержимое первой группы.</p>


	<p>Начиная с версии 3.3.1.2 преобразовывается \xFF, где FF двузначный шестнадцатеричный код символа.</p>


	<p>Пример. Получить значение nofscks из dracut.conf.</p>


<pre>
#-grep(/etc/dracut.conf,nofscks="(.*?)")-#
</pre>

	<p>Специальные символы регулярного выражения (РВ):</p>


	<p><strong>"."</strong> - соответствует любому символу, исключая новую строку. При включённом режиме <strong>dotall</strong> соответствует любому символу.<br /><strong>"^"</strong> - соответствует началу файла. При включённом режиме <strong>multiline</strong> соответствует началу строки.<br /><strong>"$"</strong> - соответствует концу файла. При включённом режиме <strong>multiline</strong> соответствует концу строки.<br /><strong>"*"</strong> - соответствует 0 и более повторении предшествующего РВ. РВ будет соответствовать максимально возможной части текста.<br /><strong>"*?"</strong> - "не жадная" версия использования предыдущего символа. РВ будет соответствовать минимально возможной части текста.<br /><strong>"+"</strong> - соответствует 1 и более повторении предшествующего РВ. РВ будет соответствовать максимально возможной части текста.<br /><strong>"+?"</strong> - "не жадная" версия использования предыдущего символа. РВ будет соответствовать минимально возможной части текста.<br /><strong>"?"</strong> - соответствует 0 или 1 повторению предшествующего РВ. РВ будет соответствовать максимально возможной части текста.<br /><strong>"??"</strong> - "не жадная" версия использования предыдущего символа. РВ будет соответствовать минимально возможной части текста.<br /><strong>"{m,n}"</strong> - соответствует от m до n повторений предшествуеющего РВ.<br /><strong>"{m,n}?"</strong> - "не жадная" версия использования предыдущей конструкции. РВ будет соответствовать минимально возможной части текста.<br /><strong>"\"</strong> - экранирвание спецсимволов<br /><strong>"[]"</strong> - соответствует любому символу из указанного набора.<br /><strong>"[^]"</strong> - соответствует любому символу не из указанного набора.<br /><strong>"A|B"</strong> - создать РВ соответствующее и А и В.<br /><strong>"(...)"</strong> - группировка РВ с сохранением групп (grep возвращает содержимое первой группы)<br /><strong>"(?ims)"</strong> - устанавливает режимы РВ: регистронезависмый, multiline, dotall.<br /><strong>"(?:...)"</strong> - группировка РВ без сохранения групп<br /><strong>"(?=...)"</strong> - проверка текста после РВ на совпадение.<br /><strong>"(?!...)"</strong> - проверка текста после РВ на не совпадение.<br /><strong>"(?&lt;=...)"</strong> - проверка текста перед РВ на совпадение (это РВ должно быть фиксированной длины).<br /><strong>"(?&lt;!...)"</strong> - проверка текста перед РВ на не совпадение (это РВ должно быть фиксированной длины).</p>


	<p><strong>"\w"</strong> - соответствует любому символу из набора [a-zA-Z0-9_]<br /><strong>"\W"</strong> - соответствует любому символу не из набора [^a-zA-Z0-9_]<br /><strong>"\s"</strong> - соответствует любому пробельному символу<br /><strong>"\S"</strong> - соответствует любому не пробельному символу<br /><strong>"\d"</strong> - соответствует любой десятичной цифре [0-9]<br /><strong>"\D"</strong> - соответствует любому символу, не являющемуся десятичной цифрой [^0-9]</p>


	<p><strong>groups(group1,group2,..groupN)</strong> - проверка вхождения пользователя в группы group1,group2, ..groupN</p>


	<p>Если пользователь входит хотя бы в одну из групп выводит '1', иначе ''</p>


	<p>group1 .. groupN - названия групп.</p>


	<p>Пример. Проверим входит ли пользователь в группу <em>wheel</em>:<br /><pre>
#-groups(wheel)-#
</pre></p>


	<p>Если пользователь входит в группу <em>wheel</em>, результатом будет '1'.</p>


	<p><strong>ini(var, value, opt)</strong> - запись и чтение переменной из конфигурационного файла пользователя (<code>~/.calculate/ini.env</code>).</p>


	<p><em>Начиная с версии 2.2.20-r4: если функция выполняется для настройки системы, то конфигурационный файл будет находиться в <code>/etc/calculate/ini.env</code>.</em></p>


где:
	<ul>
	<li><em>var</em> - имя переменной функции. Имя должно начинаться с буквы и может содержать латинские буквы и цифры, а также точку. Точка служит разделителем для раздела и имени переменной для размещения в конфигурационном файле.</li>
		<li><em>value</em> - значение переменной функции, значение присваивается переменной функции и записывается в конфигурационный файл (функция при этом возвращает пустое значение). При отсутствии второго аргумента переменная считывается из конфигурационного файла; при отсутствии названия переменной в конфигурационном файле в переменную записывается пустое значение.<br /><em>Начиная с версии 2.2.20-r4, если аргумент пустая строка без кавычек, то переменная удаляется. Если аргумент - пустая строка в кавычках, то значение переменной в ini-файле очищается.</em></li>
		<li><em>opt</em> - опция преобразования значения переменной, необязательный параметр; возможные значения url, purl, unicode. При использовании этого аргумента второй аргумент функции должен быть пустым.</li>
	</ul>


	<p>Примеры:<br />1. Создадим переменную "test" и присвоим ей значение 15, запишем в конфигурационный файл:<br /><pre>
#-ini(test,15)-#
</pre></p>


	<p>2. Считаем значение ранее записанной в конфигурационный файл переменной test, заменим функцию значением считанной переменной, в нашем случае "15":<br /><pre>
#-ini(test)-#
</pre></p>


	<p>3. Использование функции ini c тремя аргументами. Предположим,что в файле <code>~/.calculate/ini.env</code> существует секция<br /><pre>
[test]
param = Тестовый параметр
</pre></p>


	<p>тогда функция<br /><pre>
#-ini(test.param,,unicode)-#
</pre></p>


	<p>вернет<br /><pre>
\u0422\u0435\u0441\u0442\u043e\u0432\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440
</pre></p>


	<p>а функция<br /><pre>
#-ini(test.param,,url)-#
</pre></p>


	<p>вернет<br /><pre>
%d0%a2%d0%b5%d1%81%d1%82%d0%be%d0%b2%d1%8b%d0%b9%20%d0%bf%d0%b0%d1%80%d0%b0%d0%bc%d0%b5%d1%82%d1%80
</pre></p>


	<p>Опция <code>purl</code> отличается от <code>url</code> тем, что преобразует '/' в код '%2F'</p>


	<p>4. помещение сервиса sshd в автозапуск с проверкой и отметкой в ini.env<br /><pre>
# Calculate path=/etc/runlevels/default name=sshd link=/etc/init.d/sshd symbolic ini(runlevels.openssh)!=on&#38;&#38;ini(runlevels.openssh,on)==
</pre></p>


<strong>livemenu(mode)</strong> - <strong>(добавлена в версии 3.4)</strong> - функция специального назначения для формирования мультизагрузочного меню для Flash. <em>mode</em> - режим работы функции, и может быть следующим:
	<ul>
	<li>submenu - возвращает список систем в следующем формате:<br /><pre>
идентификатор системы;
полное название в загрузочном меню;
путь до ядра;
параметры для загрузки;
путь до initrd;
параметры загрузки splash;

Пример:
cl-2;
Calculate Linux Desktop Xfce;
/boot/vmlinuz-2;
root=live:LABEL=CALCULATE;
/boot/initrd-2;
splash;
</pre></li>
	</ul>


	<ul>
	<li>xorg - возвращает список систем, в которых установлен xorg-server. Например <code>cl-1 cl-2 cl-3</code>.</li>
		<li>video - возвращает список систем, в которых присутствуют проприетарные драйверы. Например <code>cl-2 cl-3</code></li>
	</ul>


	<p>Функция используется в шаблонах <code>6_ac_builder_iso/0_bootmenu/desktop.config</code>, а также для формирования <code>gfxboot.cfg</code>.</p>


	<p><strong>server(service.option,var)</strong> - чтение значения параметра сервиса. Информация получается путем обработки файла <code>/var/calculate/remote/server.env</code>,</p>


где:
	<ul>
	<li><em>service</em> - название сервиса.</li>
		<li><em>option</em> - опция сервиса.</li>
		<li><em>var</em> - имя переменной функции(необязательный параметр).<br />Разделитель <em>service</em> и <em>option</em>: '.' - точка.<br />В случае использования <em>var</em> - имени переменной функции, полученное значение опции сервиса будет записана в переменную функции <em>var</em>.<br />Если <em>var</em> не используется, полученное значение опции сервиса будет вставлено в текст конфигурационного файла.</li>
	</ul>


Примеры:
	<ol>
	<li>прочитаем значение порта для соединения с jabber-сервисом <br /><pre>
#-server(jabber,port)-#
</pre></li>
	</ol>


получаем значение 5223
	<ol>
	<li>прочитаем значение порта для соединения с jabber-сервисом и поместим в переменную функции <code>jabber_port</code><br /><pre>
#-server(jabber,port,jabber_port)-#
</pre></li>
	</ol>


	<p>Значение переменной функции jabber_port - 5223.</p>


<strong>list(var,index)</strong> - вывод значения по индексу из переменной.<br />где:
	<ul>
	<li><em>var</em> - название переменной функции или переменной шаблона (значение переменной должно быть списком).</li>
		<li><em>index</em> - индекс для поиска значения в переменной функции или переменной шаблона (первый элемент имеет индекс 0, и т.д.).</li>
	</ul>


	<p>Пример.<br />Значение переменной<br />os_disk_dev = ['/dev/sda1', '/dev/sda2', '/dev/sda3', '/dev/sda4', '/dev/sda5']</p>


<pre>
#-list(os_disk_dev,1)-#
</pre>

	<p>Метка функции будет заменена на '/dev/sda2'.</p>


	<p>Если запрошен элемент, отсутствующий в списке, наложение шаблонов прерывается с ошибкой. <em>Начиная с версии 2.2.17 - возвращает пустую строку.</em></p>


	<p><strong>in(var,value1,value2...)</strong> - проверяет есть ли среди значений переменной var, хотя бы одно значение из value. Если значение найдено, то возвращает "1", иначе пустую строку. Переменная может быть как списком, так и строкой.</p>


	<ul>
	<li><em>var</em> - название переменной</li>
		<li><em>valueX</em> - список значений для сравнения</li>
	</ul>


	<p>Пример:</p>


	<p>Значение переменной строка<br />os_install_linux_shortname = CLDX</p>


<pre>
#-in(os_install_linux_shortname,CLDX,CLD,CLDG)-#
</pre>

	<p>Пример 2:</p>


	<p>Значение переменной список<br />os_linux_pkglist = CLDX,base</p>


<pre>
#-in(os_linux_pkglist,CLDX,CLD,CLDG)-#
</pre>

	<p>Вернет 1, так как есть общее значение - CLDX.</p>


	<p>Метка функции будет заменена на CLDX.</p>


	<p><strong>kernel(kernel_opt)</strong> - <strong>(добавлена в версии 3.3.1)</strong> получить значение параметра конфигурации ядра. Возвращает "y","m" или пустую строку. y - опция включена в ядро, m - модуль ядра, пустая строка - опция выключена.</p>


	<p><em>kernel_opt</em> - регистронезависимое название опции без префикса CONFIG_</p>


	<p>Пример 1. Включен ли ext4:<br /><pre>
kernel(ext4_fs)!=
</pre></p>


	<p>Пример 1. reiserfs - модуль ядра, а ext4 - включен в ядро<br /><pre>
kernel(reiserfs_fs)==m&#38;&#38;kernel(ext4_fs)==y
</pre></p>


	<p><strong>load(arg,path,opt)</strong> - отображение информации из файла.<br />где:<br /><em>arg</em> - тип содержимого файла;<br /><em>path</em> - путь к файлу;<br /><em>opt</em> - необязательная опция</p>


Возможные значения "opt":
	<ul>
	<li><em>root</em> - путь к файлу не будет содержать chroot-пути. (Какой путь указан, такой и будет в действительности, вне зависимости от переменных <code>cl_chroot_path</code> и <code>cl_root_path</code>.)</li>
	</ul>


	<p>Возможные значения "arg":</p>


	<ul>
	<li><em>ver</em> - содержимое файла номер версии</li>
		<li><em>num</em> - содержимое файла число</li>
		<li><em>char</em> - содержимое файла строка</li>
		<li><em>empty</em> - результат, содержимое файла без закомментированных (комментарии  # или ;) и пустых строк.</li>
	</ul>


Возможные значения "path":
	<ul>
	<li><em>path</em> - абсолютный или относительный путь к файлу.</li>
	</ul>


	<p>Пример. Выведем содержимое <code>/proc/cpuinfo</code> на место объявления функции:<br /><pre>
#-load(char,/proc/cpuinfo)-#
</pre></p>


	<p><strong>module(name_space)</strong> - <strong>(удалена в 3.1)</strong> получение переменных шаблонов пакета или выполнение методов пакета, используя его api-модуль или выполнение определенного метода для всех пакетов, у которых есть api-модуль,<br />где:</p>


	<ul>
	<li><em>name_space</em> - пространство имен api-модуля.</li>
	</ul>


	<p>Пространство имен для получения переменных состоит из элементов разделенных точкой.<br />Первый элемент пространства имен - имя пакета. Имя пакета это название установленного пакета, имеющего api-модуль (тире '-' в названии должно быть заменено на нижнее подчеркивание '_').<br />Первый элемент пространства имен для всех пакетов - 'all' (зарезервированное название).<br />Пример первого элемента для пакета calculate-ldap:<br /><pre>
calculate_ldap
</pre></p>


	<p>Второй элемент пространства имен - название метода api или 'var' - зарезервированное название для пространства имен переменных шаблонов пакета.</p>


	<p>Пример первого и второго элементов для пакета <code>calculate-ldap</code> для получения доступа к переменным:<br /><pre>
calculate_ldap.var
</pre></p>


	<p>Пример первого и второго элементов для пакета <code>calculate-ldap</code> для получения результата выполнения метода <code>is_setup()</code> api-модуля (проверка, настроен ли пакет).<br /><pre>
calculate_ldap.is_setup
</pre></p>


	<p>Третий элемент пространства - в большинстве случаев это пространство имен для получения значения переменной шаблона.</p>


	<p>Пример пространства имен для получения значения переменной шаблонов <code>cl_name</code> пакета <code>calculate-ldap</code>:<br /><pre>
calculate_ldap.var.cl_name
</pre></p>


	<p>Примеры использования функции:<br />Получим значение переменной шаблонов <code>cl_name</code> (название пакета) пакета <code>calculate-ldap</code>.<br /><pre>
#-module(calculate_ldap.var.cl_name)-#
</pre></p>


	<p>Получаем значение<br /><pre>
calculate-ldap
</pre></p>


	<p>Проверим, настроен ли пакет <code>calculate-ldap</code> для работы:<br /><pre>
#-module(calculate_ldap.is_setup)-#
</pre></p>


	<p>если пакет настроен, получаем значение<br /><pre>
1
</pre></p>


	<p>Проверим, настроены ли для работы все установленные пакеты, имеющие api-модуль:</p>


<pre>
#-module(all.is_setup)-#
</pre>

	<p>Если все пакеты настроены, получаем значение<br /><pre>
1
</pre></p>


<strong>pkg (category/package)</strong> - вывод версии установленного пакета, если в системе установлено несколько версий этого пакета, ты выводится версия максимального слота.<br />где:
	<ul>
	<li><em>category</em> - категория пакета</li>
		<li><em>package</em> - название пакета</li>
		<li>Начиная с версии утилит 3.1.0_beta2 добавилась возможность указывать слот пакета через двоеточие: <code>pkg(kde-base/kdelibs:4)</code></li>
		<li>Начиная с версии утилит 3.3 добавлена возможность проверять наличие USE флагов у пакета. Проверяемые USE флаги указываются в квадратных скобках, через запятую. Указание "-" перед USE флагом означает, что флаг у пакета должен быть выключен.</li>
	</ul>


	<p>В качестве совместимого режима можно указывать только название пакета; в этом случае скорость обработки шаблона будет ниже.</p>


	<p>Пример. Выведем версию установленного пакета (например 4.2.4):<br /><pre>
#-pkg(kde-base/kdelibs)-#
</pre></p>


	<p>Значит, в системе установлен пакет <code>kdelibs-4.2.4</code>.</p>


	<p>Пример использования USE. Вывести версию установленного пакета, если он собран с включенным <code>desktop</code> и выключенным <code>client</code> флагами.<br /><pre>
#-pkg(sys-apps/calculate-utils[desktop,-client])-#
</pre></p>


	<p><strong>print (message)</strong> - вывод на экран информационного сообщения во время выполнения шаблона</p>


	<p><strong>warning (message)</strong> - вывод на экран предупреждающего сообщения во время выполнения шаблона</p>


	<p><strong>error (message)</strong> - вывод на экран сообщения об ошибке во время выполнения шаблона</p>


	<p><strong>push(var, value)</strong> - помещение значения переменной в стек переменных функций шаблонов.</p>


где:
	<ul>
	<li><em>var</em> - имя переменной функции. Имя должно начинаться с буквы и может содержать латинские буквы и цифры. Переменная создается на время обработки конфигурационного файла.</li>
		<li><em>value</em> - значение переменной функции, значение присваивается переменной функции и заносится в стек переменных функций шаблонов. При отсутствии второго аргумента, в стек переменных функций шаблонов будет записано значение переменной.</li>
	</ul>


Примеры:
	<ol>
	<li>Создадим переменную "test" и присвоим ей значение 15, запишем в стек переменных функций шаблонов.<br /><pre>
#-push(test,15)-#
</pre></li>
	</ol>


	<ol>
	<li>Запишем в стек переменных функций шаблонов значение ранее созданной переменной <code>test</code>:<br /><pre>
#-push(test)-#
</pre></li>
	</ol>


<strong>pop(var)</strong> - извлечение значения из стека переменных функций шаблонов и присвоение его переменной.
	<ul>
	<li><em>var</em> - имя переменной функции. Имя должно начинаться с буквы и может содержать латинские буквы и цифры. Переменная создается на время обработки конфигурационного файла.</li>
	</ul>


Примеры:
	<ol>
	<li>Создадим переменную "test" и присвоим ей значение 15, запишем в стек переменных функций шаблонов.<br /><pre>
#-push(test,15)-#
</pre></li>
	</ol>


	<ol>
	<li>Получим значение из стека переменных функций шаблонов и присвоим его переменной <code>test2</code>:<br /><pre>
#-pop(test2)-#
</pre></li>
	</ol>


	<p>Получить значение из стека переменных функций шаблонов возможно как в текущем шаблоне, так и в любом другом.<br />После получения значения оно удаляется из стека.</p>


<strong>replace(old, new, var)</strong> - замена в значении переменной <code>var</code> текста <em>old</em> на <em>new</em>.<br />где:
	<ul>
	<li><em>old</em> - текст, каждое вхождение которого в значении переменной будет заменено на текст <em>new</em></li>
		<li><em>new</em> - текст, на который в значении переменной будет заменен текст <em>old</em></li>
		<li><em>var</em> - название переменной функции или переменной шаблона</li>
	</ul>


	<p>Текст <em>old</em> и <em>new</em> должен быть заключен в двойные или одинарные кавычки.</p>


	<p>В тексте в двойных кавычках обрабатываются управляющие символы (\', \", \n, \r, \t, \\).<br />Начиная с версии 3.2.3-r3 в двойных кавычках также обрабатывается \xFF, где FF двузначный шестнадцатеричный код символа. <br />В одинарных кавычках текст не обрабатывается.</p>


	<p>Пример.<br />значение переменной шаблона <em>ur_signature</em><br /><pre>
Компания «Калкулэйт»\nРоссия, Санкт-Петербург, пл. Стачек, 4\nhttp://www.calculate.ru\n+7 812 3363632\n+7 495 7727678
</pre></p>


	<p>при выполнении функции<br /><pre>
#-replace('\n',"\n",ur_signature)-#
</pre></p>


	<p>в точку вставки будет вставлен следующий текст (символ "\n" будет заменен на перевод строки)<br /><pre>
Компания «Калкулэйт»
Россия, Санкт-Петербург, пл. Стачек, 4
http://www.calculate.ru
+7 812 3363632
+7 495 7727678
</pre></p>


	<p>Ниже приведенный пример позволяет преобразовать пробел в значении <code>hr_board_model</code> в символ подчеркивания.<br /><pre>
...
|main.hr_board_model | rs  |            |P8H77-V LE|
...

#?replace("\x20","_",main.hr_board_model)==P8H77-V_LE#
...
#replace#
</pre></p>


<strong>rnd(type,len)</strong> - вывод случайной комбинации символов.<br />где:
	<ul>
	<li><em>type</em> - используемые символы, возможные значения: num - числа, pas - числа и буквы, uuid - числа и буквы от a-f. (uuid добавлен начиная с версии 2.2.17).</li>
		<li><em>len</em> - количество символов (число).</li>
	</ul>


	<p>Пример. Выведем три 3 случайных числа (например 372):<br /><pre>
#-rnd(num,3)-#
</pre></p>


	<p><strong>sum(var,sum_print, sum_out)</strong> - вычисляемые значения смещений. Функция разрабатывалась для настройки <noindex><a href="http://ru.wikipedia.org/wiki/Plasma_(KDE)" rel="nofollow" target="_blank" class="external">Plasma</a></noindex> (KDE).</p>


где:
	<ul>
	<li><em>var</em> - имя переменной функции "sum". Имя должно начинаться с буквы и может содержать латинские буквы и цифры. Переменная создается на время обработки конфигурационного файла.</li>
		<li><em>sum_print</em> - арифметическое выражение, результат которого будет отображен на месте объявления функции. При отсутствии аргумента значение выводиться не будет. Поддерживаются операции сложения "+" и вычитания "-", деления "/" и умножения "*". В арифметическом выражении могут участвовать другие переменные функции, а также переменные шаблона.</li>
		<li><em>sum_out</em> - арифметическое выражение, результат которого будет присвоен переменной "var" (первому аргументу функции). При отсутствии третьего аргумента переменной "var" будет присвоено вычисленное значение второго аргумента.</li>
	</ul>


Примеры:
	<ol>
	<li>Создадим переменную "clock" и присвоим ей значение 15, не выводя результат.<br /><pre>
#-sum(clock,,15)-#
</pre></li>
	</ol>


	<ol>
	<li>Создадим переменную "bt", присвоим ей значение переменной "clock" и выведем значение.<br /><pre>
#-sum(bt,clock)-#
</pre></li>
	</ol>


	<ol>
	<li>Разместим кнопку на панели шириной "35" пикселов, оставив отступ в "4" пиксела по краям:<br /><pre>
#-sum(bt,bt+2,bt+35+2)-#
</pre></li>
	</ol>


	<p><strong>wallpaper(resolution, wallpapers_path)</strong> - <strong>(добавлена в 3.2.3)</strong> функция выбирает наиболее подходящее по указанному разрешению изображение из папки.</p>


где:
	<ul>
	<li><em>resolution</em> - требуемое разрешение (текущее разрешение можно получить из переменных <code>os_x11_resolution</code>, <code>os_install_x11_resolution</code>)</li>
		<li><em>wallpapers_path</em> - путь, где находится изображение в разных разрешениях. Формат файлов: <code>разрешение.расширение</code>. Например: 1024x768.jpg</li>
	</ul>


	<p>Пример:</p>


Папка <code>/usr/share/wallpapers/1</code> содержит следующие изображения:
	<ul>
	<li>1024x768.jpg</li>
		<li>1280x1024.jpg</li>
		<li>1680x1050.jpg</li>
		<li>1920x1080.jpg</li>
	</ul>


<pre>
#-wallpaper(1280x720,/usr/share/wallpapers/1)-#
</pre>

	<p>вернет 1920x1080.jpg как наиболее подходящую по пропорциям.</p>


	<p>Для получения текущего разрешения можно использовать выше указанные переменные<br /><pre>
#-wallpaper(#-install.os_install_x11_resolution-#,/usr/share/wallpapers/1)-#
</pre></p>


	<h3 id="Способы-объединения">Способы объединения<a href="#Способы-объединения" class="wiki-anchor">&para;</a></h3>


Существуют несколько способов объединения шаблона установки с исходным файлом системы:
	<ul>
	<li><strong>join</strong> - основной способ объединения - методом слияния двух файлов. Подробно описан в "схеме объединения".</li>
		<li><strong>before</strong> - шаблон переписывается в начало оригинального файла</li>
		<li><strong>after</strong> - шаблон переписывается в конец оригинального файла</li>
		<li><strong>replace</strong> - шаблон переписывается заменяя оригинальный файл</li>
		<li><strong>delete</strong> - объединение не происходит, оригинальный файл удаляется</li>
		<li><strong>remove</strong> - вместо объединения происходит удаление оригинального файла</li>
	</ul>


Изменение шаблона перед объединением, для способов объединения "before", "after", "replace":
	<ul>
	<li>если существуют <em>управляющие элементы</em>, то они обрабатываются</li>
		<li>если существует <em>заголовок</em>, то он обрабатывается</li>
		<li>если существует параметр <em>format</em> в <em>заголовке</em> то происходит обработка <em>управляющих символов</em>: "+, -, !"</li>
	</ul>


	<h4>Правила по умолчанию</h4>


	<p>По умолчанию способ объединения устанавливается в соответствии с форматом файла.<br />Для форматов файлов основных приложений "samba", "bind" и т.п. по умолчанию действует объединение "join", для формата "raw" и "bin" - объединение "replace". Для пустого файла по умолчанию действует правило объединения "delete" - конечный файл удаляется из системы.</p>


	<p>Правила объединения могут быть изменены установкой параметра "append" заголовка файла шаблона.</p>


	<h2 id="Расположение">Расположение<a href="#Расположение" class="wiki-anchor">&para;</a></h2>


	<h3 id="Правила-именования-файлов">Правила именования файлов<a href="#Правила-именования-файлов" class="wiki-anchor">&para;</a></h3>


	<p>Имена файлов шаблона могут содержать условные операторы, определяющие правила, при выполнении которых файл шаблона будет перенесен в систему. Подобно ссылке на страницу сайта условия отделяются от имени знаком вопроса (?), после которого могут идти условные операторы, подробно описанные в условных блоках (см. выше).</p>


	<p>Арифметические операции могут объединяться условием И (&#38;) и ИЛИ (?). Приоритет в данном случае будет отдаваться условию И.</p>


	<p>Пример:<br /><pre>
grub.conf?os_linux_shortname==CDS?os_linux_shortname==CLD
</pre></p>


	<p>В приведенном примере файл шаблона выполнит настройки загрузчика как для систем <a href="Calculate Linux Desktop.html" class="wiki-page">Calculate Linux Desktop</a>, так и для <a href="Calculate Directory Server.html" class="wiki-page">Calculate Directory Server</a>.</p>


	<p>При наличии условных операторов в заголовке файла шаблона для переноса файла шаблона в систему должны выполняться оба условных выражения.</p>


	<h3 id="Правила-именования-директорий">Правила именования директорий<a href="#Правила-именования-директорий" class="wiki-anchor">&para;</a></h3>


	<p>Правила именования директорий схожи с правилами именования файлов. При выполнении условий, заданных условными операторами, директория будет перенесена в систему; в противном случае директория вместе с содержимым будет пропущена.</p>


	<h3 id="Права-доступа">Права доступа<a href="#Права-доступа" class="wiki-anchor">&para;</a></h3>


Права доступа конфигурационного файла после объединения с файлом шаблона устанавливаются по следующим приоритетам:
	<ul>
	<li>при наличии конфигурационного файла в системе права будут сохранены неизменными;</li>
		<li>в случае отсутствия оригинального конфигурационного файла, права будут выставлены как 644 для файла и 755 для директории;</li>
		<li>в случае установки значения переменной "chmod" или "chown" заголовка файла шаблона, права на конфигурационный файл будут изменены согласно установленному значению.</li>
	</ul>


	<h3 id="Символические-ссылки">Символические ссылки<a href="#Символические-ссылки" class="wiki-anchor">&para;</a></h3>


	<p>Для создания символических ссылок используйте параметры "link + symbolic" заголовка файла шаблона.</p>


	<p>Если помимо заголовка файл шаблона будет содержать тело шаблона, оригинальный файл будет модифицирован согласно правилам объединения.</p>


	<p>Calculate не будет переносить так называемые "битые ссылки" - ссылки, не ведущие ни на какой файл (директорию), если явно не указан параметр <code>force</code>.</p>


	<h2 id="Схема-объединения">Схема объединения<a href="#Схема-объединения" class="wiki-anchor">&para;</a></h2>


	<p>Объединение - изменение настроек оригинального файла настроек в соответствии с настройками <em>файла шаблона</em>.</p>


	<p>В процессе объединения все записи оригинального файла и файла шаблона разбиваются на <em>элементы</em>: <em>области,  переменные, списки, разделённые списки, комментарии, управляющие элементы</em> (см. ниже).</p>


	<p>Файл шаблона должен быть составлен с применением синтаксиса оригинального файла. Расположение элементов оригинального файла при объединении сохраняется. Во время объединения комментарии из файла шаблона не переносятся.</p>


	<h3 id="Правила-объединения">Правила объединения<a href="#Правила-объединения" class="wiki-anchor">&para;</a></h3>


	<p>Над элементами могут происходит операции <em>Объединение, Замена, Удаление</em>:</p>


	<h4>Объединение</h4>


	<ul>
	<li>Отсутствующие в оригинальном файле элементы дописываются в конец области. При этом в случае наличия перевода строки перед вставляемым элементом перевод строки добавляется после вставляемого элемента. В противном случае перевод строки добавляется перед вставляемым элементом.</li>
		<li>В случае объединения разделённого списка, отсутствующие элементы добавляются следом за последним элементом разделённого списка конфигурационного файла.</li>
	</ul>


	<h4>Замена</h4>


	<ul>
	<li>Значение элементов заменяется на новое. При этом форматирование переносится из файла шаблона.</li>
	</ul>


	<h4>Удаление</h4>


	<ul>
	<li>Элемент удаляется вместе с переводом строки, стоящим перед элементом.</li>
	</ul>


	<h3 id="Правила-объединения-действующие-по-умолчанию">Правила объединения, действующие по умолчанию<a href="#Правила-объединения-действующие-по-умолчанию" class="wiki-anchor">&para;</a></h3>


	<p>Правила объединения действуют на <strong>элементы с одним именем</strong>, расположенные в <strong>одной области шаблона</strong>.</p>


<strong>При нахождении различий, по умолчанию действуют следующие правила:</strong>
	<ul>
	<li><strong>Области</strong> - содержимое двух областей <em>объединяется (+)</em>.</li>
		<li><strong>Переменные</strong> - значения переменных <em>заменяются (-)</em>.</li>
		<li><strong>Списки</strong> - содержимое списков <em>заменяется (-)</em>.</li>
		<li><strong>Разделённые списки</strong> - аналогично правилу объединения переменных - значения списков <em>заменяются (-)</em>.</li>
	</ul>


	<h3 id="Изменение-правил-объединения">Изменение правил объединения<a href="#Изменение-правил-объединения" class="wiki-anchor">&para;</a></h3>


Для изменения правил объединения действующих по умолчанию, в начале <strong>имени элемента</strong> в файле шаблона добавляется управляющие символы:
	<ul>
	<li><strong>"+"</strong> - объединить элементы (для областей и списков); после объединения остаются только уникальные элементы</li>
		<li><strong>"-"</strong> - значение элемента заменяется</li>
		<li><strong>"!"</strong> - элемент удаляется<br />В CXmlConf описания файла шаблона эти правила описываются тэгом "&lt;action&gt;".</li>
	</ul>


	<h2 id="Формат-CXmlConf">Формат CXmlConf<a href="#Формат-CXmlConf" class="wiki-anchor">&para;</a></h2>


	<p>CXmlConf - универсальный формат описания конфигурационных файлов. Служит для <strong>выборочного изменения настроек</strong> большинства распространенных типов конфигурационных файлов ОС Linux/Unix.</p>


	<p>XML файл описания настроек разбивает конфигурационный файл на логические структуры - <strong>элементы</strong>, пригодные для последующего объединения. После объединения файл может быть преобразован в первозданный вид за некоторыми исключениями (см. Схема объединения).</p>


	<p>Описания элементов вкладываются в конструкцию:<br /><pre>
&lt;cxmlconf&gt;
  &lt;head&gt;
    &lt;ver&gt;версия формата&lt;/ver&gt;
    &lt;format&gt;формат конфигурационного файла&lt;/format&gt;
  &lt;/head&gt;
  &lt;body&gt;
    [&lt;area&gt;...&lt;/area&gt;... &lt;field&gt;..&lt;/field&gt;]
  &lt;/body&gt;
&lt;/cxmlconf&gt;
</pre></p>


Где:
	<ul>
	<li><em>ver</em> - передает номер версии разметки</li>
		<li><em>format</em> - формат конфигурационного файла (определяется по распространенным программам).</li>
	</ul>


	<p>Все элементы (см. ниже) помещаются внутрь элемента &lt;body/&gt;.</p>


	<h3 id="Области">Области<a href="#Области" class="wiki-anchor">&para;</a></h3>


	<p>Области конфигурационных файлов разграничивают <strong>пространство имен переменных</strong>. Области могут содержать логические структуры, в том числе другие области (пример: {{Filename|named.conf}}).</p>


	<p>Области помещается в конструкцию:<br /><pre>
&lt;area&gt;
  &lt;caption&gt;
    &lt;name&gt;Заголовок области&lt;/name&gt;
    &lt;action&gt;join|replace|drop&lt;/action&gt;
    &lt;quote&gt;Начальная часть области (заголовок)&lt;/quote&gt;
    &lt;quote&gt;Завершающая часть описания области&lt;/quote&gt;
  &lt;/caption&gt;

  [&lt;field&gt;&lt;/field&gt;...]

&lt;/area&gt;
</pre></p>


	<h3 id="Переменные">Переменные<a href="#Переменные" class="wiki-anchor">&para;</a></h3>


	<p>Переменные имеют запись в виде:<br /><pre>
&lt;field type="var"&gt;
  &lt;name&gt;имя переменной&lt;/name&gt;
  &lt;value&gt;значение переменной&lt;/value&gt;
  &lt;action&gt;join|replace|drop&lt;/action&gt;
  &lt;quote&gt;Оригинальный текст описания&lt;/quote&gt;
&lt;/field&gt;
</pre></p>


	<p>В некоторых конфигурационных файлах, например, <code>/etc/openldap/slapd.conf</code>, встречается конструкция:<br /><pre>
index   cn              pres,sub,eq
index   sn              pres,sub,eq
index   uid             pres,sub,eq
</pre></p>


	<p>В этом случае имя переменной состоит из первой и второй части, а значение - из третьей.</p>


	<p>Cтрока<br /><pre>
index   cn              pres,sub,eq
</pre></p>


	<p>В XML это будет выглядеть так:<br /><pre>
&lt;field type="var"&gt;
  &lt;name&gt;indexcn&lt;/name&gt;
  &lt;value&gt;pres,sub,eq&lt;/value&gt;
  &lt;quote&gt;index   cn              pres,sub,eq&lt;/quote&gt;
&lt;/field&gt;
&lt;field type="br" \&gt;
</pre></p>


	<h3 id="Списки">Списки<a href="#Списки" class="wiki-anchor">&para;</a></h3>


	<p>По примеру файла <code>named.conf</code>, блок "listen-on" может содержать одни значения - значения блока, а не переменных.</p>


	<p>Для обозначения значений служит конструкция:<br /><pre>
&lt;field type="list"&gt;
  &lt;name&gt;hostsallow&lt;/name&gt;
  &lt;value&gt;192.168.0.0/24&lt;/value&gt;
  &lt;value&gt;127.&lt;/value&gt;
  &lt;action&gt;join|replace|drop&lt;/action&gt;
  &lt;quote&gt;Оригинальный текст списка&lt;/quote&gt;
&lt;/field&gt;
</pre></p>


	<p>где внутри блока "&lt;quote&gt;" сохраняется оригинальный текст описания значения, без завершающего перевода строки.</p>


	<h3 id="Разделённые-списки">Разделённые списки<a href="#Разделённые-списки" class="wiki-anchor">&para;</a></h3>


	<p>Файл настроек веб-сервера <em>Apache</em> может содержать инструкцию "Include", позволяющую делать исходный файл модульным. Подобные случаи описываются в "CXmlConf", как "Разделённые списки".</p>


	<p>Разделенные списки описываются следующей конструкцией:<br /><pre>
&lt;field type="seplist"&gt;
  &lt;name&gt;Include&lt;/name&gt;
  &lt;value&gt;/etc/apache2/modules.d/*.conf&lt;/value&gt;
  &lt;action&gt;join|replace|drop&lt;/action&gt;
  &lt;quote&gt;Оригинальный текст списка&lt;/quote&gt;
&lt;/field&gt;
</pre></p>


	<h3 id="Комментарии">Комментарии<a href="#Комментарии" class="wiki-anchor">&para;</a></h3>


	<p>При объединении конфигурационных файлов комментарии оригинального файла сохраняются в неизменном виде.</p>


	<p>Все типы комментариев помещаются в конструкцию "&lt;comment&gt;". В тексте, помещаемом в "&lt;quote/&gt;", сохраняются символы комментария и перевод строки:<br /><pre>
&lt;field type="comment"&gt;
  &lt;quote&gt;Оригинальный текст комментария&lt;/quote&gt;
&lt;/field&gt;
</pre></p>


	<p>Комментарии не могут быть вложенными (быть описаны в других конструкциях комментариев).</p>


	<h3 id="Управляющие-элементы">Управляющие элементы<a href="#Управляющие-элементы" class="wiki-anchor">&para;</a></h3>


	<p>Для обозначения <strong>перевода строк</strong> служит конструкция:<br /><pre>
&lt;field type="br"&gt;
  &lt;quote&gt;разделительные элементы (пробелы, табуляция)&lt;/quote&gt;
&lt;/field&gt;
</pre></p>


Где:
	<ul>
	<li>"quote" содержит элементы форматирования (пробелы, табуляция)</li>
	</ul>


	<h2 id="Формат-XML">Формат XML<a href="#Формат-XML" class="wiki-anchor">&para;</a></h2>


	<h3 id="Поддерживаемые-форматы-XML">Поддерживаемые форматы XML<a href="#Поддерживаемые-форматы-XML" class="wiki-anchor">&para;</a></h3>


	<p>В настоящее время реализована поддержка форматов xml_xfce (XML файл для конфигурирования оконного менеджера XFCE), xml_xfcepanel (XML файл для конфигурирования панелей оконного менеджера XFCE), xml_gconf (XML файл для конфигурирования GNOME)</p>


	<h3 id="Отличия-от-формата-CXmlConf">Отличия от формата CXmlConf<a href="#Отличия-от-формата-CXmlConf" class="wiki-anchor">&para;</a></h3>


	<ul>
	<li>XML файлы хранятся и обрабатываются без перевода их в другой формат.</li>
		<li>Все правила, функции, переменные действуют на файл XML-шаблона аналогично обычному шаблону за исключением операций объединения элементов XML</li>
	</ul>


	<h3 id="Объединение-элементов-XML">Объединение элементов XML<a href="#Объединение-элементов-XML" class="wiki-anchor">&para;</a></h3>


	<p>Для объединения элементов XML в тексте XML шаблона используется атрибут XML-элемента - 'action'</p>


Допустимые значения атрибута
	<ul>
	<li>action="join" - элементы объединяются (действует по умолчанию)</li>
		<li>action="replace" - элемент шаблона замещает элемент файла</li>
		<li>action="drop" - элемент файла удаляется</li>
	</ul>


	<h4>Формат xml_xfce</h4>


	<p>Формат состоит из элементов "channel" и "property".</p>


	<p>В атрибутах "channel" находится имя и версия файла.</p>


	<p>Внутри элемента "channel" находятся элементы "property".</p>


	<p>Пример элемента "channel":<br /><pre>
&lt;channel name="xfwm4" version="1.0"&gt;
  &lt;property name="general" type="empty"&gt;
  .....
  &lt;/property&gt;
&lt;/channel&gt;
</pre></p>


	<p>Пример элемента "property":<br /><pre>
&lt;property name="wrap_workspaces" type="bool" value="false"/&gt;
</pre></p>


	<p>У каждого элемента "property" есть атрибут type.</p>


	<p>Если type="array", то этот элемент и внутренние элементы будут заменены на элементы из шаблона.<br />Иначе элементы будут объединены.</p>


	<p>Пример type="array":<br /><pre>
&lt;property name="workspace_names" type="array"&gt;
  &lt;value type="string" value="Рабочее место 1"/&gt;
  &lt;value type="string" value="Рабочее место 2"/&gt;
  &lt;value type="string" value="Рабочее место 3"/&gt;
  &lt;value type="string" value="Рабочее место 4"/&gt;
&lt;/property&gt;
</pre></p>


	<h4>Формат xml_xfcepanel</h4>


	<p>Формат состоит из следующих элементов: "panels", "panel", "properties", "property", "items", "item".</p>


	<p>Если элемент "items", то этот элемент и внутренние элементы будут заменены на элементы из шаблона.<br />Иначе элементы будут объединены.</p>


	<p>Пример элемента "items":<br /><pre>
&lt;items&gt;
  &lt;item name="xfce4-mixer-plugin" id="9"/&gt;
  &lt;item name="clock" id="10"/&gt;
  &lt;item name="separator" id="52"/&gt;
  &lt;item name="actions" id="12"/&gt;
&lt;/items&gt;
</pre></p>


	<h4>Формат xml_gconf</h4>


	<p>Формат состоит из элементов "entry".<br />Если у элемента "entry" есть атрибут "ltype" (список) или атрибут <em>type="string"</em> то этот элемент и внутренние элементы будут заменены на элементы из шаблона, в ином случае элементы будут объединены.</p>


	<p>Атрибут элемента "entry" - "mtime" при изменении элемента "entry" показывает время, когда произошло изменение в секундах.</p>


	<p>Пример шаблона xml_gconf:<br /><pre>
# Calculate format=xml_gconf
&lt;?xml version="1.0"?&gt;
&lt;gconf&gt;
        &lt;entry name="rgba_order" mtime="1235158855" type="string"&gt;
              &lt;stringvalue&gt;rgb&lt;/stringvalue&gt;
       &lt;/entry&gt;
       &lt;entry name="dpi" mtime="1235162438" type="float" value="86"&gt;
       &lt;/entry&gt;
       &lt;entry name="hinting" mtime="1235266915" type="string"&gt;
               &lt;stringvalue&gt;full&lt;/stringvalue&gt;
       &lt;/entry&gt;
       &lt;entry name="antialiasing" mtime="1235266915" type="string"&gt;
               &lt;stringvalue&gt;rgba&lt;/stringvalue&gt;
       &lt;/entry&gt;
&lt;/gconf&gt;
</pre></p>


	<h4>Формат xml_gconf_tree</h4>


	<p>Формат состоит из элементов "dir" и "entry" и их атрибутов.</p>


	<p>Атрибуты элементов будут объединены в случае 'join'-объединения.</p>


	<p>При объединении шаблона и конфигурационного файла элементы "entry" конфигурационного файла будут заменены, соответствующими элементами "entry" шаблона.</p>


	<p>Атрибут элемента "entry" - "mtime" при изменении элемента "entry" показывает время когда произошло изменение в секундах.</p>


	<p>Пример шаблона xml_gconf:<br /><pre>
# Calculate format=xml_gconf_tree
&lt;?xml version="1.0"?&gt;
&lt;gconf&gt;
    &lt;dir name="desktop"&gt;
        &lt;dir name="gnome"&gt;
            &lt;dir name="volume_manager"&gt;
                &lt;entry name="percent_used" mtime="1285580987" schema="/schemas/desktop/gnome/volume_manager/percent_used"/&gt;
                        &lt;/dir&gt;
                &lt;/dir&gt;
        &lt;/dir&gt;
&lt;gconf&gt;
</pre></p>


	<h3 id="Примеры-использования">Примеры использования<a href="#Примеры-использования" class="wiki-anchor">&para;</a></h3>


	<p>Файл шаблона:<br /><pre>
# Calculate format=xml_xfce
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;channel name="xfce4-session" version="1.0"&gt;
  &lt;property name="general" type="empty" action="drop"&gt;
    &lt;property name="FailsafeSessionName" type="empty"/&gt;
    &lt;property name="SessionName" type="string" value="Default"/&gt;
    &lt;property name="SaveOnExit" type="bool" value="true"/&gt;
  &lt;/property&gt;   
&lt;/channel&gt;
</pre></p>


	<p>Cтрока <em>&lt;property name="general" type="empty" action="drop"&gt;</em> говорит о том, что этот элемент и все элементы внутри будут удалены.</p>


	<p>Получившийся в результате файл имеет следующий вид:<br /><pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;channel name="xfce4-session" version="1.0"&gt;
&lt;/channel&gt;
</pre></p>


	<h2 id="Формат-patch">Формат 'patch'<a href="#Формат-patch" class="wiki-anchor">&para;</a></h2>


	<p>Формат <em>patch</em> используется для обработки конфигурационных файлов при помощи регулярных выражений языка программирования Python.</p>


	<h3 id="Особенности">Особенности.<a href="#Особенности" class="wiki-anchor">&para;</a></h3>


	<p>Формат <em>patch</em> использует обработку конфигурационного файла на основании шаблона  (тип объединения <em>patch</em>); при этом не происходит объединения шаблона и конфигурационного файла.</p>


	<p>Обработка исходного файла происходит целиком, а не построчно, поэтому символы '<code>^</code>' и '<code>$</code>' означают  соответственно начало и конец файла. Символ '<code>.</code>' означает любой символ исключая перевод строки.</p>


	<p>Начиная с версии <code>calculate-lib-3.1.7-r5</code> в параметры заголовка для <code>format=patch</code> добавлены опции <strong>multiline</strong> и <strong>dotall</strong>. При включенном <strong>multiline</strong> '<code>^</code>' и '<code>$</code>' обозначают начало и конец строки. При включенном <strong>dotall</strong> '<code>.</code>' включает в себя перевод строки.</p>


	<h3 id="Описание">Описание.<a href="#Описание" class="wiki-anchor">&para;</a></h3>


	<p>Шаблон формата <em>patch</em>:<br /><pre>
# Calculate format=patch
&lt;reg&gt;регулярное выражение python 1&lt;/reg&gt;
&lt;text&gt;текст 1 для замены регулярного выражения&lt;/text&gt;
&lt;reg&gt;регулярное выражение python 2&lt;/reg&gt;
&lt;text&gt;текст 2 для замены регулярного выражения&lt;/text&gt;
...
</pre></p>


	<p>В содержимом тегов <code>reg</code> и <code>text</code> символы "&#38;", "<", ">" должны быть заменены на "&amp;amp;", "&amp;lt;", "&amp;gt;" соответственно.</p>


	<p>Пример:<br /><pre>
# Calculate format=patch
&lt;reg&gt;TEXT&amp;amp;DATA&lt;/reg&gt;
&lt;text&gt;TEXT_CONFIG&lt;/text&gt;
</pre></p>


	<p>Этот шаблон заменит в конфигурационном файле <em>TEXT&#38;DATA</em> на <em>TEXT_CONFIG</em>.</p>


	<h2 id="Формат-diff">Формат 'diff'<a href="#Формат-diff" class="wiki-anchor">&para;</a></h2>


	<p>Добавлен начиная с версии 3.1.4</p>


	<p>Формат <em>diff</em> используется для наложение diff патчей на исходный код пакета. Сам файл в системе не создается, а полученное содержимое обрабатывается относительно каталога указанного в параметре <code>path</code>.</p>


	<p>Пример:<br /><pre>
# Calculate format=diff
--- panel-plugin/xkb-cairo.c    2012-07-17 16:23:24.997030066 +0400
+++ panel-plugin/xkb-cairo.c    2012-07-17 16:47:34.107054590 +0400
@@ -27,7 +27,7 @@
 #include "xkb-util.h" 
 #include "xfce4-xkb-plugin.h" 

-#define XKB_PREFERRED_FONT "Courier New, Courier 10 Pitch, Monospace Bold %d" 
+#define XKB_PREFERRED_FONT "Droid Sans, Courier New, Courier 10 Pitch, Monospace Bold %d" 
</pre></p>


	<h2 id="Формат-kernel">Формат 'kernel'<a href="#Формат-kernel" class="wiki-anchor">&para;</a></h2>


	<p>Добавлен начиная с версии 3.3.0.16</p>


	<p>Формат <em>kernel</em> используется для объединения конфигурационных файлов ядра без сохранения комментариев.</p>


	<p>Пример:<br /><pre>
# Calculate format=kernel
CONFIG_XFS_FS=m
CONFIG_REISERFS_FS=y
# CONFIG_EXT3_FS is not set
!CONFIG_EXT3_FS_POSIX_ACL=
!CONFIG_EXT3_FS_SECURITY=
!CONFIG_EXT3_FS_XATTR=
</pre></p>


	<h2 id="Формат-dconf">Формат 'dconf'<a href="#Формат-dconf" class="wiki-anchor">&para;</a></h2>


	<p>Добавлен, начиная с версии 3.3.2.9</p>


	<p>Формат <em>dconf</em> используется для модификации настроек пользователя, хранящихся в реестре dconf. Формат <em>dconf</em> поддерживает параметр заголовка <em>dconfpath</em> для возможности изменять базовый путь настроек.</p>


	<p>Пример:<br /><pre>
# Calculate format=dconf dconf=/org/gnome/eog/
[view]
background-color='#000000'
use-background-color=true

[ui]
statusbar=true
toolbar=true
sidebar=false
</pre></p>


	<p>Для применения шаблонов формата <em>dconf</em>, утилиты используют пакет <code>gnome-base/dconf</code>.</p>


	<h2 id="Формат-json">Формат 'json'<a href="#Формат-json" class="wiki-anchor">&para;</a></h2>


	<p>Добавлен, начиная с версии 3.4.1</p>


	<p>Формат <em>json</em> используется для модификации настроек в формате json (например <code>Perferences</code> пакета <code>www-client/chromium</code>).</p>


	<p>Пример <em>json</em><br /><pre>
{"google": {"services": {"signin": {"LSID": "", "SID": ""}}},
 "intl": {"accept_languages": "ru-RU,ru,en-US,en", "status": 1}}
</pre></p>


	<p>При объединении элементов в конфигурационном файле меняются только конкретные значения.</p>


	<p>Для изменения правил объединения действующих по умолчанию, в начале <strong>имени элемента</strong> в файле шаблона добавляется управляющие символы:</p>


	<ul>
	<li><strong>"-"</strong> - ветка заменяется</li>
		<li><strong>"!"</strong> - ветка удаляется</li>
	</ul>


	<p>Пример объединения<br /><pre>
# Calculate format=json
{"intl":{"accept_languages": "en"}}
</pre></p>


<pre>
{"google": {"services": {"signin": {"LSID": "", "SID": ""}}},
 "intl": {"accept_languages": "en", "status": 1}}
</pre>

	<p>Пример удаления<br /><pre>
# Calculate format=json
{"!intl":""}
</pre></p>


<pre>
{"google": {"services": {"signin": {"LSID": "", "SID": ""}}}}
</pre>

	<p>Пример замещения<br /><pre>
# Calculate format=json
{"-intl":{"accept_languages": "en"}}
</pre></p>


<pre>
{"google": {"services": {"signin": {"LSID": "", "SID": ""}}},
 "intl": {"accept_languages": "en"}}
</pre>

	<p>Ветка настроек также будет замещена если в шаблоне содержится значение.</p>


	<p>Пример замещения<br /><pre>
# Calculate format=json
{"intl": 5}
</pre></p>


<pre>
{"google": {"services": {"signin": {"LSID": "", "SID": ""}}},
 "intl": 5}
</pre>
</body>
</html>
