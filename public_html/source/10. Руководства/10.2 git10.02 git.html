<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>git</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style>
body { font:80% Verdana,Tahoma,Arial,sans-serif; }
h1, h2, h3, h4 {  font-family: "Trebuchet MS",Georgia,"Times New Roman",serif; }
ul.toc { padding: 4px; margin-left: 0; }
ul.toc li { list-style-type:none; }
ul.toc li.heading2 { margin-left: 1em; }
ul.toc li.heading3 { margin-left: 2em; }
a.wiki-anchor { display: none; margin-left: 6px; text-decoration: none; }
a.wiki-anchor:hover { color: #aaa !important; text-decoration: none; }
h1:hover a.wiki-anchor, h2:hover a.wiki-anchor, h3:hover a.wiki-anchor { display: inline; color: #ddd; }
pre {font-size:133% }
</style>
</head>
<body>
<h1 id="Основы-работы-с-Git">Основы работы с Git<a href="#Основы-работы-с-Git" class="wiki-anchor">&para;</a></h1>


	<ul class="toc"><li class="heading1"><a href="#Основы-работы-с-Git">Основы работы с Git</a></li>
<li class="heading2"><a href="#Введение">Введение</a></li>
<li class="heading2"><a href="#Основы-работы-с-удаленным-репозиторием">Основы работы с удаленным репозиторием</a></li>
<li class="heading3"><a href="#git-clone-—-создание-копии-удаленного-репозитория">git clone — создание копии (удаленного) репозитория</a></li>
<li class="heading3"><a href="#git-fetch-и-git-pull-—-забираем-изменения-из-центрального-репозитория">git fetch и git pull — забираем изменения из центрального репозитория</a></li>
<li class="heading3"><a href="#git-push-—-вносим-изменения-в-удаленный-репозиторий">git push — вносим изменения в удаленный репозиторий</a></li>
<li class="heading2"><a href="#Работа-с-локальным-репозиторием">Работа с локальным репозиторием</a></li>
<li class="heading3"><a href="#Базовые-команды">Базовые команды</a></li>
<li class="heading3"><a href="#Ветвление">Ветвление</a></li>
<li class="heading3"><a href="#Прочие-команды-и-необходимые-возможности">Прочие команды и необходимые возможности</a></li>
<li class="heading2"><a href="#Серверные-команды-репозитория">Серверные команды репозитория</a></li>
<li class="heading2"><a href="#Рецепты">Рецепты</a></li>
<li class="heading2"><a href="#Ссылки">Ссылки</a></li>
</ul>


	<h2 id="Введение">Введение<a href="#Введение" class="wiki-anchor">&para;</a></h2>


	<p><strong>Git</strong> (произн. «гит») - распределённая система управления версиями файлов. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux. На сегодняшний день поддерживается Джунио Хамано.</p>


	<p>Система спроектирована как набор программ, специально разработанных с учётом их использования в скриптах. Это позволяет удобно создавать специализированные системы контроля версий на базе Git или пользовательские интерфейсы. Например, Cogito является именно таким примером фронтенда к репозиториям Git, а StGit использует Git для управления коллекцией патчей.</p>


	<p>Git поддерживает быстрое разделение и слияние версий, включает инструменты для визуализации и навигации по нелинейной истории разработки. Как и Darcs, BitKeeper, Mercurial, SVK, Bazaar и Monotone, Git предоставляет каждому разработчику локальную копию всей истории разработки; изменения копируются из одного репозитория в другой.</p>


	<p>Удалённый доступ к репозиториям Git обеспечивается git-daemon, gitosis, SSH- или HTTP-сервером. TCP-сервис git-daemon входит в дистрибутив Git и является наряду с SSH наиболее распространённым и надёжным методом доступа. Метод доступа по HTTP, несмотря на ряд ограничений, очень популярен в контролируемых сетях, потому что позволяет использовать существующие конфигурации сетевых фильтров.</p>


	<h2 id="Основы-работы-с-удаленным-репозиторием">Основы работы с удаленным репозиторием<a href="#Основы-работы-с-удаленным-репозиторием" class="wiki-anchor">&para;</a></h2>


	<h3 id="git-clone-—-создание-копии-удаленного-репозитория">git clone — создание копии (удаленного) репозитория<a href="#git-clone-—-создание-копии-удаленного-репозитория" class="wiki-anchor">&para;</a></h3>


	<p>Для начала работы с центральным репозиторием, следует создать копию оригинального проекта со всей его историей локально.</p>


	<p>Клонируем репозиторий, используя протокол http:<br /><pre>
git clone http://user@somehost:port/~user/repository/project.git
</pre></p>


	<p>Клонируем репозиторий с той же машины в директорию <code>myrepo</code>:<br /><pre>
git clone /home/username/project myrepo
</pre></p>


	<p>Клонируем репозиторий, используя безопасный протокол ssh:<br /><pre>
git clone ssh://user@somehost:port/~user/repository
</pre></p>


	<p>У git имеется и собственный протокол:<br /><pre>
git clone git://user@somehost:port/~user/repository/project.git/
</pre></p>


	<p>Импортируем svn репозиторий, используя протокол http:<br /><pre>
git svn clone -s http://repo/location
</pre><br /><strong>-s</strong> – понимать стандартные папки SVN (trunk, branches, tags)</p>


	<h3 id="git-fetch-и-git-pull-—-забираем-изменения-из-центрального-репозитория">git fetch и git pull — забираем изменения из центрального репозитория<a href="#git-fetch-и-git-pull-—-забираем-изменения-из-центрального-репозитория" class="wiki-anchor">&para;</a></h3>


	<p>Для синхронизации текущей ветки с репозиторием используются команды git fetch и git pull.</p>


	<p>git fetch — забрать изменения удаленной ветки из репозитория по умолчания, основной ветки; той, которая была использована при клонировании репозитория. Изменения обновят удаленную ветку (remote tracking branch), после чего надо будет провести слияние с локальной ветку командой git merge.</p>


	<p>git fetch /home/username/project — забрать изменения из определенного репозитория.</p>


	<p>Возможно также использовать синонимы для адресов, создаваемые командой <code>git remote</code>:<br /><pre>
git remote add username-project /home/username/project
</pre></p>


	<p>git fetch username-project — забрать изменения по адресу, определяемому синонимом.</p>


	<p>Естественно, что после оценки изменений, например, командой <code>git diff</code>, надо создать коммит слияния с основной:<br /><pre>
git merge username-project/master
</pre></p>


	<p>Команда <code>git pull</code> сразу забирает изменения и проводит слияние с активной веткой.</p>


	<p>Забрать из репозитория, для которого были созданы удаленные ветки по умолчанию:<br /><pre>
git pull
</pre></p>


	<p>Забрать изменения и метки из определенного репозитория:<br /><pre>
git pull username-project --tags
</pre></p>


	<p>Как правило, используется сразу команда <code>git pull</code>.</p>


	<h3 id="git-push-—-вносим-изменения-в-удаленный-репозиторий">git push — вносим изменения в удаленный репозиторий<a href="#git-push-—-вносим-изменения-в-удаленный-репозиторий" class="wiki-anchor">&para;</a></h3>


	<p>После проведения работы в экспериментальной ветке, слияния с основной, необходимо обновить удаленный репозиторий (удаленную ветку). Для этого используется команда git push.</p>


	<p>Отправить свои изменения в удаленную ветку, созданную при клонировании по умолчанию:<br /><pre>
git push
</pre></p>


	<p>Отправить изменения из ветки master в ветку experimental удаленного репозитория:<br /><pre>
git push ssh://yourserver.com/~you/proj.git master:experimental
</pre></p>


	<p>В удаленном репозитории origin удалить ветку experimental:<br /><pre>
git push origin :experimental
</pre></p>


	<p>В удаленную ветку master репозитория origin (синоним репозитория по умолчанию) ветки локальной ветки master:<br /><pre>
git push origin master:master
</pre></p>


	<p>Отправить метки в удаленную ветку master репозитория origin:<br /><pre>
git push origin master --tags
</pre></p>


	<p>Изменить указатель для удаленной ветки master репозитория origin (master будет такой же как и develop)<br /><pre>
git push origin origin/develop:master
</pre></p>


	<p>Добавить ветку test в удаленный репозиторий origin, указывающую на коммит ветки develop:<br /><pre>
git push origin origin/develop:refs/heads/test
</pre></p>


	<h2 id="Работа-с-локальным-репозиторием">Работа с локальным репозиторием<a href="#Работа-с-локальным-репозиторием" class="wiki-anchor">&para;</a></h2>


	<h3 id="Базовые-команды">Базовые команды<a href="#Базовые-команды" class="wiki-anchor">&para;</a></h3>


	<h4>git init — создание репозитория</h4>


	<p>Команда <code>git init</code> создает в директории пустой репозиторий в виде директории <code>.git</code>, где и будет в дальнейшем храниться вся информация об истории коммитов, тегах — о ходе разработки проекта:<br /><pre>
mkdir project-dir
cd project-dir
git init
</pre></p>


	<h4>git add и git rm — индексация изменений</h4>


	<p>Следующее, что нужно знать — команда <code>git add</code>. Она позволяет внести в индекс — временное хранилище — изменения, которые затем войдут в коммит. Примеры использования:</p>


	<p>индексация измененного файла, либо оповещение о создании нового:<br /><pre>git add EDITEDFILE</pre></p>


	<p>внести в индекс все изменения, включая новые файлы:<br /><pre>git add .</pre></p>


	<p>Из индекса и дерева проекта одновременно файл можно удалить командой <code>git rm</code>:</p>


	<p>отдельные файлы:<br /><pre>git rm FILE1 FILE2</pre></p>


	<p>хороший пример удаления из документации к git, удаляются сразу все файлы txt из папки:<br /><pre>git rm Documentation/\*.txt</pre></p>


	<p>внести в индекс все удаленные файлы:<br /><pre>git rm -r --cached .</pre></p>


	<p>Сбросить весь индекс или удалить из него изменения определенного файла можно<br />командой <code>git reset</code>:</p>


	<p>сбросить весь индекс:<br /><pre>git reset</pre></p>


	<p>удалить из индекса конкретный файл:<br /><pre>git reset — EDITEDFILE</pre></p>


	<p>Команда <code>git reset</code> используется не только для сбрасывания индекса, поэтому дальше<br />ей будет уделено гораздо больше внимания.</p>


	<h4>git status — состояние проекта, измененные и не добавленные файлы, индексированные файлы</h4>


	<p>Команду <code>git status</code>, пожалуй, можно считать самой часто используемой наряду с<br />командами коммита и индексации. Она выводит информацию обо всех изменениях,<br />внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей<br />ветки; отдельно выводятся внесенные в индекс и неиндексированные<br />файлы. Использовать ее крайне просто:<br /><pre>
git status
</pre></p>


	<p>Кроме того, <code>git status</code> указывает на файлы с неразрешенными конфликтами слияния и<br />файлы, игнорируемые git.</p>


	<h4>git commit — совершение коммита</h4>


	<p>Коммит — базовое понятие во всех системах контроля версий, поэтому совершаться<br />он должен легко и по возможности быстро. В простейшем случае достаточно<br />после индексации набрать:<br /><pre>
git commit
</pre></p>


	<p>Если индекс не пустой, то на его основе будет совершен коммит, после чего<br />пользователя попросят прокомментировать вносимые изменения вызовом команды<br /><code>edit</code>. Сохраняемся, и вуаля! Коммит готов.</p>


	<p>Есть несколько ключей, упрощающих работу с <code>git commit</code>:<br /><pre>
git commit -a
</pre>совершит коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено.<br /><pre>
git commit -m «commit comment»
</pre>комментируем коммит прямо из командной строки вместо текстового редактора.<br /><pre>
git commit FILENAME
</pre>внесет в индекс и создаст коммит на основе изменений единственного файла.</p>


	<h4>git reset — возврат к определенному коммиту, откат изменений, «жесткий» или «мягкий»</h4>


	<p>Помимо работы с индексом (см. выше), <code>git reset</code> позволяет сбросить состояние проекта до какого-либо коммита в истории. В git данное действие может быть двух видов: «мягкого»(soft reset) и «жесткого» (hard reset).</p>


	<p>«Мягкий» (с ключом <code>--soft</code>) резет оставит нетронутыми ваши индекс и все дерево файлов и директорий проекта, вернется к работе с указанным коммитом. Иными словами, если вы обнаруживаете ошибку в только что совершенном коммите или комментарии к нему, то легко можно исправить ситуацию:</p>


	<ol>
	<li>git commit — некорректный коммит</li>
		<li>git reset --soft HEAD^ — переходим к работе над уже совершенным коммитом, сохраняя все состояние проекта и проиндексированные файлы</li>
		<li>edit WRONGFILE</li>
		<li>edit ANOTHERWRONGFILE</li>
		<li>git add .</li>
		<li>git commit -c ORIG_HEAD — вернуться к последнему коммиту, будет предложено редактировать его сообщение. Если сообщение оставить прежним, то достаточно изменить регистр ключа -с: <pre>git commit -C ORIG_HEAD</pre></li>
	</ol>


	<p>Обратите внимание на обозначение HEAD^, оно означает «обратиться к предку последнего коммита». Подробней описан синтаксис такой относительной адресации будет ниже, в разделе «Хэши, тэги, относительная адресация». Соответственно, HEAD — ссылка на последний коммит. Ссылка ORIG_HEAD после «мягкого» резета указывает на оригинальный коммит.</p>


	<p>Естественно, можно вернуться и на большую глубину коммитов,</p>


	<p>«Жесткий» резет (ключ <code>--hard</code>) — команда, которую следует использовать с<br />осторожностью. <code>git reset --hard</code> вернет дерево проекта и индекс в состояние,<br />соответствующее указанному коммиту, удалив изменения последующих коммитов:</p>


<pre>
git add .
git commit -m «destined to death»
git reset --hard HEAD~1 — больше никто и никогда не увидит этот позорный коммит...
git reset --hard HEAD~3 — ...вернее, три последних коммита. Никто. Никогда!
</pre>

	<p>Если команда достигнет точки ветвления, удаления коммита не произойдет.</p>


	<p>Для команд слияния или выкачивания последних изменений с удаленного репозитория<br />примеры резета будут приведены в соответствующих разделах.</p>


	<h4>git revert — отмена изменений, произведенных в прошлом отдельным коммитом</h4>


	<p>Возможна ситуация, в которой требуется отменить изменения, внесенные отдельным коммитом. <code>git revert</code> создает новый коммит, накладывающий обратные изменения.</p>


	<p>Отменяем коммит, помеченный тегом:<br /><pre>
git revert config-modify-tag
</pre></p>


	<p>Отменяем коммит, используя его хэш:<br /><pre>
git revert cgsjd2h
</pre></p>


	<p>Для использования команды необходимо, чтобы состояние проекта не отличалось от состояния, зафиксированного последним коммитом.</p>


	<h4>git log — разнообразная информация о коммитах в целом</h4>


	<p>Иногда требуется получить информацию об истории коммитов; коммитах, изменивших<br />отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих<br />целей используется команда <code>git log</code>.</p>


	<p>Простейший пример использования, в котором приводится короткая справка по всем<br />коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении<br />подробно узнать можно ниже, в разделе «Ветвления и слияния»):<br /><pre>
git log
</pre></p>


	<p>Получить подробную информацию о каждом в виде патчей по файлам из коммитов<br />можно, добавив ключ -p (или -u):<br /><pre>
git log -p
</pre></p>


	<p>Статистика изменения файлов, вроде числа измененных файлов, внесенных в них<br />строк, удаленных файлов вызывается ключом <code>--stat</code>:<br /><pre>
git log --stat
</pre></p>


	<p>За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ<br /><code>--summary</code>:<br /><pre>
git log --summary
</pre></p>


	<p>Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра<br />его имя (кстати, в моей старой версии <code>git</code> этот способ не срабатывает,<br />обязательно добавлять " — " перед «README»):<br /><pre>
git log README
</pre></p>


	<p>или, если версия git не совсем свежая:<br /><pre>
git log — README
</pre></p>


	<p>Далее будет приводится только более современный вариант синтаксиса. Возможно<br />указывать время, начиная в определенного момента («weeks», «days», «hours», «s»<br />и так далее):</p>


<pre>
git log --since=«1 day 2 hours» README
git log --since=«2 hours» README
</pre><br />изменения, касающиеся отдельной папки:<br /><pre>
git log --since=«2 hours» dir/
</pre>

	<p>Можно отталкиваться от тегов.</p>


	<p>Все коммиты, начиная с тега v1:<br /><pre>
git log v1...
</pre><br />Все коммиты, включающие изменения файла README, начиная с тега v1:<br /><pre>
git log v1... README
</pre><br />Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:<br /><pre>
git log v1..v2 README
</pre></p>


	<p>Интересные возможности по формату вывода команды предоставляет ключ <code>--pretty</code>.</p>


	<p>Вывести на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):<br /><pre>
git log --pretty=oneline
</pre><br />Лаконичная информация о коммитах, приводятся только автор и комментарий:<br /><pre>
git log --pretty=short
</pre><br />Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:<br /><pre>
git log --pretty=full/fuller
</pre></p>


	<p>В принципе, формат вывода можно определить самостоятельно:<br /><pre>
git log --pretty=format:'FORMAT'
</pre></p>


	<p>Определение формата можно поискать в разделе по <code>git log</code> из <em>Git Community Book</em><br />или справке. Красивый ASCII-граф коммитов выводится с использованием ключа<br /><code>--graph</code>.</p>


	<h4>git diff — отличия между деревьями проекта, коммитами и т.д.</h4>


	<p>Своего рода подмножеством команды <code>git log</code> можно считать команду <code>git diff</code>,<br />определяющую изменения между объектами в проекте - деревьями (файлов и<br />директорий).</p>


	<p>Показать изменения, не внесенные в индекс:<br /><pre>
git diff
</pre><br />Изменения, внесенные в индекс:<br /><pre>
git diff --cached
</pre><br />Изменения в проекте по сравнению с последним коммитом:<br /><pre>
git diff HEAD
</pre><br />Предпоследним коммитом:<br /><pre>
git diff HEAD^
</pre><br />Можно сравнивать «головы» веток:<br /><pre>
git diff master..experimental
</pre><br />или активную ветку с какой-либо:<br /><pre>
git diff experimental
</pre></p>


	<h4>git show — показать изменения, внесенные отдельным коммитом</h4>


	<p>Посмотреть изменения, внесенные любым коммитом в истории, можно командой <code>git show</code>:<br /><pre>
git show COMMIT_TAG
</pre></p>


	<h4>git blame и git annotate — команды, помогающие отслеживать изменения файлов</h4>


	<p>При работе в команде часто требуется выяснить, кто именно написал конкретный<br />код. Удобно использовать команду <code>git blame</code>, выводящую построчную информацию о<br />последнем коммите, коснувшемся строки, имя автора и хэш коммита:<br /><pre>
git blame README
</pre></p>


	<p>Можно указать и конкретные строки для отображения:<br /><pre>
git blame -L 2,+3 README — выведет информацию по трем строкам, начиная со второй.
</pre></p>


	<p>Аналогично работает команда <code>git annotate</code>, выводящая и строки, и информацию о<br />коммитах, их коснувшихся:<br /><pre>
git annotate README
</pre></p>


	<h4>git grep — поиск слов по проекту, состоянию проекта в прошлом</h4>


	<p><code>git grep</code>, в целом, просто дублирует функционал знаменитой юниксовой<br />команды. Однако он позволяет слова и их сочетания искать в прошлом проекта, что<br />бывает очень полезно.</p>


	<p>Поиск слова <em>tst</em> в проекте:<br /><pre>
git grep tst
</pre></p>


	<p>Подсчитать число упоминаний <em>tst</em> в проекте:<br /><pre>
git grep -с tst
</pre></p>


	<p>Поиск в старой версии проекта:<br /><pre>
git grep tst v1
</pre></p>


	<p>Команда позволяет использовать логическое И и ИЛИ.</p>


	<p>Найти строки, где упоминаются и первое слово, и второе:<br /><pre>
git grep -e 'first' --and -e 'another'
</pre></p>


	<p>Найти строки, где встречается хотя бы одно из слов:<br /><pre>
git grep --all-match -e 'first' -e 'second'
</pre></p>


	<h3 id="Ветвление">Ветвление<a href="#Ветвление" class="wiki-anchor">&para;</a></h3>


	<h4>git branch — создание, перечисление и удаление веток</h4>


	<p>Работа с ветками — очень легкая процедура в git, все необходимые механизмы сконцентрированы в одной команде:</p>


	<p>Просто перечислить существующие ветки, отметив активную:<br /><pre>
git branch
</pre><br />Создать новую ветку new-branch:<br /><pre>
git branch new-branch
</pre><br />Удалить ветку, если та была залита (merged) с разрешением возможных конфликтов в текущую:<br /><pre>
git branch -d new-branch
</pre><br />Удалить ветку в любом случае:<br /><pre>
git branch -D new-branch
</pre><br />Переименовать ветку:<br /><pre>
git branch -m new-name-branch
</pre><br />Показать те ветки, среди предков которых есть определенный коммит:<br /><pre>
git branch --contains v1.2
</pre></p>


	<h4>git checkout — переключение между ветками, извлечение файлов</h4>


	<p>Команда <code>git checkout</code> позволяет переключаться между последними коммитами (если упрощенно) веток:</p>


<pre>checkout some-other-branch</pre><br />Создаст ветку, в которую и произойдет переключение <pre>checkout -b some-other-new-branch</pre>

	<p>Если в текущей ветке были какие-то изменения по сравнению с последним коммитом в ветке(HEAD), то команда откажется производить переключение, дабы не потерять произведенную работу. Проигнорировать этот факт позволяет ключ <code>-f</code>:<br /><pre>
checkout -f some-other-branch
</pre></p>


	<p>В случае, когда изменения надо все же сохранить, следует использовать ключ <code>-m</code>. Тогда команда перед переключением попробует залить изменения в текущую ветку и, после разрешения возможных конфликтов, переключиться в новую:<br /><pre>
checkout -m some-other-branch
</pre></p>


	<p>Вернуть файл (или просто вытащить из прошлого коммита) позволяет команда вида:</p>


	<p>Вернуть <em>somefile</em> к состоянию последнего коммита:<br /><pre>
git checkout somefile
</pre></p>


	<p>Вернуть <em>somefile</em> к состоянию на два коммита назад по ветке:<br /><pre>
git checkout HEAD~2 somefile
</pre></p>


	<h4>git merge — слияние веток (разрешение возможных конфликтов)</h4>


	<p>Слияние веток, в отличие от обычной практики централизованных систем, в git происходит практически каждый день. Естественно, что имеется удобный интерфейс к популярной операции.</p>


	<p>Попробовать объединить текующую ветку и ветку new-feature:<br /><pre>
git merge new-feature
</pre></p>


	<p>В случае возникновения конфликтов коммита не происходит, а по проблемным файлам расставляются специальные метки а-ля svn; сами же файлы отмечаются в индексе как «не соединенные» (unmerged). До тех пор пока проблемы не будут решены, коммит совершить будет нельзя.</p>


	<p>Например, конфликт возник в файле <code>TROUBLE</code>, что можно увидеть в <code>git status</code>.</p>


	<p>Произошла неудачная попытка слияния:<br /><pre>
git merge experiment
</pre></p>


	<p>Смотрим на проблемные места:<br /><pre>
git status
</pre></p>


	<p>Разрешаем проблемы:<br /><pre>
edit TROUBLE
</pre></p>


	<p>Индексируем наши изменения, тем самым снимая метки:<br /><pre>
git add .
</pre></p>


	<p>Совершаем коммит слияния:<br /><pre>
git commit
</pre></p>


	<p>Вот и все, ничего сложного. Если в процессе разрешения вы передумали разрешать конфликт, достаточно набрать (это вернёт обе ветки в исходные состояния):</p>


<pre>
git reset --hard HEAD
</pre>

	<p>Если же коммит слияния был совершен, используем команду:<br /><pre>
git reset --hard ORIG_HEAD
</pre></p>


	<h4>git rebase — построение ровной линии коммитов</h4>


	<p>Предположим, разработчик завел дополнительную ветку для разработки отдельной возможности и совершил в ней несколько коммитов. Одновременно по какой-либо причине в основной ветке также были совершены коммиты: например, в нее были залиты изменения с удаленного сервера, либо сам разработчик совершал в ней коммиты.</p>


	<p>В принципе, можно обойтись обычным <code>git merge</code>. Но тогда усложняется сама линия разработки, что бывает нежелательно в слишком больших проектах, где участвует множество разработчиков.</p>


	<p>Предположим, имеется две ветки, master и topic, в каждой из которых было совершенно несколько коммитов начиная с момента ветвления. Команда <code>git rebase</code> берет коммиты из ветки topic и накладывает их на последний коммит ветки master.</p>


	<p>Вариант, в котором явно указывается, что и куда накладывается:<br /><pre>
git-rebase master topic
</pre></p>


	<p>на master накладывается активная в настоящий момент ветка:<br /><pre>
git-rebase master
</pre></p>


	<p>После использования команды история становится линейной. При возникновении конфликтов при поочередном накладывании коммитов работа команды будет останавливаться, а в проблемные местах файлов появятся соответствующие метки. После редактирования — разрешения конфликтов — файлы следует внести в индекс командой <code>git add</code> и продолжить наложение следующих коммитов командой <code>git rebase --continue</code>. Альтернативными выходами будут команды <code>git rebase --skip</code> (пропустить наложение коммита и перейти к следующему) или <code>git rebase --abort</code> (отмена работы команды и всех внесенных изменений).</p>


	<p>С ключом <code>-i</code> (<code>--interactive</code>) команда будет работать в интерактивном режиме. Пользователю будет предоставлена возможность определить порядок внесения изменений, автоматически будет вызывать редактор для разрешения конфликтов и так далее.</p>


	<h4>git cherry-pick — применение к дереву проекта изменений, внесенных отдельным коммитом</h4>


	<p>Если ведется сложная история разработки, с несколькими длинными ветками разработками, может возникнуть необходимость в применении изменений, внесенных отдельным коммитом одной ветки, к дереву другой (активной в настоящий момент).</p>


	<p>Изменения, внесенные указанным коммитом будут применены к дереву, автоматически проиндексированы и станут коммитом в активной ветке:<br /><pre>
git cherry-pick BUG_FIX_TAG
</pre></p>


	<p>Ключ <code>-n</code> показывает, что изменения надо просто применить к дереву проекта без индексации и создания коммита<br /><pre>
git cherry-pick BUG_FIX_TAG -n
</pre></p>


	<h3 id="Прочие-команды-и-необходимые-возможности">Прочие команды и необходимые возможности<a href="#Прочие-команды-и-необходимые-возможности" class="wiki-anchor">&para;</a></h3>


	<h4>Хэш — уникальная идентификация объектов</h4>


	<p>В git для идентификации любых объектов используется уникальный (то есть с огромной вероятностью уникальный) хэш из 40 символов, который определяется хэшируюшей функцией на основе содержимого объекта. Объекты — это все: коммиты, файлы, тэги, деревья. Поскольку хэш уникален для содержимого, например, файла, то и сравнивать такие файлы очень легко — достаточно просто сравнить две строки в сорок символов.</p>


	<p>Больше всего нас интересует тот факт, что хэши идентифицируют коммиты. В этом смысле хэш — продвинутый аналог ревизий Subversion. Несколько примеров использования хэшей в качестве способа адресации:</p>


	<p>найти разницу текущего состояния проекта и коммита за номером… сами видите, каким:<br /><pre>
git diff f292ef5d2b2f6312bc45ae49c2dc14588eef8da2
</pre></p>


	<p>То же самое, но оставляем только шесть первых символов. Git поймет, о каком коммите идет речь, если не существует другого коммита с таким началом хэша:<br /><pre>
git diff f292ef5
</pre></p>


	<p>Иногда хватает и четырех символов:<br /><pre>
git diff f292
</pre></p>


	<p>Читаем лог с коммита по коммит:<br /><pre>
git log febc32...f292
</pre></p>


	<p>Разумеется, человеку пользоваться хэшами не так удобно, как машине, именно поэтому были введены другие объекты — тэги.</p>


	<h4>git tag — тэги как способ пометить уникальный коммит</h4>


	<p>Тэг (tag) — это объект, связанный с коммитом; хранящий ссылку на сам коммит, имя автора, собственное имя и некоторый комментарий. Кроме того, разработчик может оставлять на таких тегах собственную цифровую подпись.</p>


	<p>Кроме этого в git представленные так называемые «легковесные тэги» (<em>lightweight tags</em>), состоящие только из имени и ссылки на коммит. Такие тэги, как правило, используются для упрощения навигации по дереву истории; создать их очень легко.</p>


	<p>Создать «легковесный» тэг, связанный с последним коммитом; если тэг уже есть, то еще один создан не будет:<br /><pre>git tag stable-1</pre></p>


	<p>Пометить определенный коммит:<br /><pre>
git tag stable-2 f292ef5
</pre></p>


	<p>Удалить тег:<br /><pre>
git tag -d stable-2
</pre></p>


	<p>Перечислить тэги:<br /><pre>
git tag -l
</pre></p>


	<p>Создать тэг для последнего коммита, заменить существующий, если таковой уже был:<br /><pre>
git tag -f stable-1.1
</pre></p>


	<p>После создания тэга его имя можно использовать вместо хэша в любых командах вроде <code>git diff</code>, <code>git log</code> и так далее:<br /><pre>
git diff stable-1.1...stable-1
</pre></p>


	<p>Обычные тэги имеет смысл использовать для приложения к коммиту какой-либо информации, вроде номера версии и комментария к нему. Иными словами, если в комментарии к коммиту пишешь «исправил такой-то баг», то в комментарии к тэгу по имени «v1.0» будет что-то вроде «стабильная версия, готовая к использованию».</p>


	<p>Создать обычный тэг для последнего коммита; будет вызван текстовый редактор для составления комментария:<br /><pre>
git tag -a stable
</pre></p>


	<p>Создать обычный тэг, сразу указав в качестве аргумента комментарий:<br /><pre>
git tag -a stable -m "production version" 
</pre></p>


	<p>Команды перечисления, удаления, перезаписи для обычных тэгов не отличаются от команд для «легковесных» тэгов.</p>


	<h4>Относительная адресация</h4>


	<p>Вместо ревизий и тэгов в качестве имени коммита можно опираться на еще один механизм — относительную адресацию. Например, можно обратиться прямо к предку последнего коммита ветки master:<br /><pre>
git diff master^
</pre></p>


	<p>Если после «птички» поставить цифру, то можно адресоваться по нескольким предкам коммитов слияния:</p>


	<p>найти изменения по сравнению со вторым предком последнего коммита в master; HEAD здесь — указатель на последний коммит активной ветки:<br /><pre>
git diff HEAD^2
</pre></p>


	<p>Аналогично, тильдой можно просто указывать, насколько глубоко в историю ветки нужно погрузиться:</p>


	<p>что привнес «дедушка» нынешнего коммита:<br /><pre>
git diff master^^
</pre></p>


	<p>То же самое:<br /><pre>
git diff master~2
</pre></p>


	<p>Обозначения можно объединять, чтобы добраться до нужного коммита:<br /><pre>
git diff master~3^~2
git diff master~6
</pre></p>


	<h4>файл .gitignore — объясняем git, какие файлы следует игнорировать</h4>


	<p>Иногда по директориям проекта встречаются файлы, которые не хочется постоянно видеть в сводке <code>git status</code>. Например, вспомогательные файлы текстовых редакторов, временные файлы и прочий мусор.</p>


	<p>Заставить <code>git status</code> игнорировать определенные файлы можно, создав в корне или глубже по дереву (если ограничения должны быть только в определенных директория) файл <code>.gitignore</code>. В этих файлах можно описывать шаблоны игнорируемых файлов определенного формата.</p>


	<p>Пример содержимого такого файла:<br /><pre>
#комментарий к файлу .gitignore
#игнорируем сам .gitignore
.gitignore
#все html-файлы...
*.html
#...кроме определенного
!special.html
#не нужны объектники и архивы
*.[ao]
</pre></p>


	<p>Существуют и другие способы указания игнорируемых файлов, о которых можно узнать из справки <code>git help gitignore</code>.</p>


	<h2 id="Серверные-команды-репозитория">Серверные команды репозитория<a href="#Серверные-команды-репозитория" class="wiki-anchor">&para;</a></h2>


	<p>; git update-server-info : Команда создает вспомогательные файлы для dumb-сервера в $GIT_DIR/info и $GIT_OBJECT_DIRECTORY/info каталогах, чтобы помочь клиентам узнать, какие ссылки и пакеты есть на сервере.</p>


	<p>; git count-objects : Проверка, сколько объектов будет потеряно и объём освобождаемого места при перепаковке репозитория.<br />; git gc : Переупаковка локального репозитория.</p>


	<h2 id="Рецепты">Рецепты<a href="#Рецепты" class="wiki-anchor">&para;</a></h2>


	<p><strong>Создание пустого репозитория на сервере</strong><br /><pre>
repo="repo.git" 
mkdir $repo
cd $repo
git init --bare
chown git. -R ./
cd ../
</pre></p>


	<p><strong>Импорт svn репозитория на Git-сервер</strong><br /><pre>
repo="repo.svn" 
svnserver="http://svn.calculate.ru" 
git svn clone -s $svnserver/$repo $repo
mv $repo/.git/refs/remotes/tags $repo/.git/refs/tags
rm -rf $repo/.git/refs/remotes
rm -rf $repo/.git/svn
mv $repo/.git $repo.git
rm -rf $repo
cd $repo.git
chown git. -R ./
cd ../
</pre></p>


	<h2 id="Ссылки">Ссылки<a href="#Ссылки" class="wiki-anchor">&para;</a></h2>


	<ul>
	<li><a href="правка коммитов.html" class="wiki-page">правка коммитов</a></li>
		<li><noindex><a href="http://leonid.shevtsov.me/22-07-2009/perenos-svn-repozitariya-v-git/" rel="nofollow" target="_blank" class="external">Перенос SVN-репозитория в git</a></noindex></li>
		<li><noindex><a href="http://freesource.info/wiki/RuslanHihin/GitTutorial1?v=3pr" rel="nofollow" target="_blank" class="external">Учебник-введение в git</a></noindex></li>
		<li><noindex><a href="http://freesource.info/wiki/RuslanHihin/GitUserManual?v=3fj" rel="nofollow" target="_blank" class="external">Руководство пользователя GIT</a></noindex></li>
		<li><noindex><a href="http://freesource.info/wiki/RuslanHihin/20povsedevnyxkomandgit" rel="nofollow" target="_blank" class="external">20 повседневных команд git</a></noindex></li>
		<li><noindex><a href="http://los-t.livejournal.com/tag/git+guts" rel="nofollow" target="_blank" class="external">Внутренности git</a></noindex></li>
		<li><noindex><a href="http://blog.tarantsov.com/2008/11/essential-git.html" rel="nofollow" target="_blank" class="external">Введение в структуру хранилища git</a></noindex></li>
		<li><noindex><a href="http://admdev.blogspot.com/2009/02/git.html" rel="nofollow" target="_blank" class="external">Практическое введение в git</a></noindex></li>
		<li><noindex><a href="http://blog.nsws.ru/rabota-s-git-dlya-nachinayushhix.html" rel="nofollow" target="_blank" class="external">Работа с git для начинающих</a></noindex></li>
		<li><noindex><a href="http://git.or.cz/course/svn.html" rel="nofollow" target="_blank" class="external">Переходим с SVN на Git</a></noindex></li>
		<li><noindex><a href="http://habrahabr.ru/blogs/Git/75728/" rel="nofollow" target="_blank" class="external">ХХ полезных советов для пользователей Git среднего уровня. Часть 1</a></noindex></li>
		<li><noindex><a href="http://habrahabr.ru/blogs/Git/76084/" rel="nofollow" target="_blank" class="external">ХХ полезных советов для пользователей Git среднего уровня. Часть 2</a></noindex></li>
		<li><noindex><a href="http://habrahabr.ru/blogs/Git/75964/" rel="nofollow" target="_blank" class="external">Внешние зависимости в гите: submodule или subtree?</a></noindex></li>
		<li><noindex><a href="http://habrahabr.ru/blogs/Git/75990/" rel="nofollow" target="_blank" class="external">Командная работа в Git</a></noindex></li>
	</ul>
</body>
</html>
